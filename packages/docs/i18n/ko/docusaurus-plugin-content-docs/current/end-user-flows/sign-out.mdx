---
sidebar_position: 6
---

# 로그아웃

Logto (OIDC 기반 아이덴티티 제공자)에서의 로그아웃 프로세스는 Logto가 관리하는 중앙화된 로그인 세션과 클라이언트 애플리케이션이 관리하는 분산된 인증 상태가 모두 관여하기 때문에 다면적인 개념입니다.

## 로그인 세션 \{#sign-in-session}

로그아웃 프로세스를 더 잘 이해하기 위해서는 Logto에서 사용자 로그인 세션과 인증 상태가 어떻게 관리되는지를 먼저 이해하는 것이 중요합니다.

```mermaid
  sequenceDiagram
    autonumber
    actor User

    box Relying Party (RP)
      participant Client as 클라이언트 애플리케이션
    end

    box Logto (IdP)
      participant OIDC as OIDC 제공자
      participant SignIn as 로그인 페이지
    end

    User ->> Client: 웹 애플리케이션에 접근
    Client ->> OIDC: 인증을 위해 OIDC로 사용자 리디렉션
    OIDC -->> OIDC: 사용자의 로그인 세션 확인
    OIDC ->> SignIn: 사용자에게 로그인 요청
    SignIn ->> OIDC: 사용자를 식별하고 상호작용 결과 제출
    OIDC -->> OIDC: 사용자의 로그인 세션 및 인증 권한 설정
    OIDC ->> Client: 인증 코드와 함께 웹 애플리케이션으로 사용자 리디렉션 (Authorization Code 흐름)
    Client ->> OIDC: 코드를 토큰으로 교환
    OIDC -->> Client: 토큰 반환
```

1. 사용자가 웹 애플리케이션 (RP)에 접근합니다.
2. 클라이언트 애플리케이션이 사용자를 Logto (IdP)로 [인증 (Authentication)](https://auth.wiki/authentication)을 위해 리디렉션합니다.
3. OIDC 제공자가 사용자의 로그인 세션 상태를 확인합니다. 세션이 없거나 만료된 경우, 사용자에게 로그인을 요청합니다.
4. 사용자가 로그인 페이지와 상호작용하여 인증을 받습니다.
5. 성공적으로 로그인한 후, Logto는 사용자에 대한 새로운 세션을 생성하고 클라이언트 애플리케이션으로 인가 코드와 함께 리디렉션합니다.
6. OIDC 제공자가 사용자에 대한 새로운 로그인 세션 및 인증 권한을 생성합니다.
7. OIDC 제공자가 사용자에게 인증 코드와 함께 클라이언트로 리디렉션합니다 ([Authorization Code 흐름](https://auth.wiki/authorization-code-flow)).
8. 클라이언트가 인증 코드를 받고 사용자 정보를 액세스하기 위해 토큰으로 교환합니다.
9. 클라이언트 애플리케이션에 토큰을 부여합니다.

## 구성 요소 \{#components}

### Logto가 관리하는 중앙화된 로그인 세션 \{#centralized-sign-in-session-managed-by-logto}

위의 흐름에서 중앙화된 로그인 세션은 Logto에 의해 관리됩니다. 사용자가 성공적으로 로그인하면 세션이 생성되고, 사용자가 로그아웃하면 세션이 파괴됩니다. 사용자의 세션이 만료되면 세션도 파괴됩니다.

Logto 로그인 세션은 세션 쿠키를 사용하여 관리됩니다. 사용자가 로그인하면 세션 쿠키가 설정됩니다. 모든 인증 요청은 세션 쿠키에 대해 검증됩니다. 세션 쿠키가 존재하고 유효하면 사용자는 자동으로 인증되고 인가 코드와 함께 클라이언트 애플리케이션으로 직접 리디렉션됩니다. 그렇지 않으면 사용자는 로그인 요청을 받게 됩니다.

1. 공유된 Logto 세션 쿠키
   동일한 사용자 에이전트 (예: 브라우저)에서 여러 클라이언트 애플리케이션에 로그인하는 사용자는 Logto 도메인 아래에 공유된 세션 쿠키를 갖게 됩니다. 이는 사용자가 한 번만 로그인하면 다른 클라이언트 애플리케이션에 자동으로 인증될 수 있음을 의미합니다.

   ```mermaid
    flowchart TD
    subgraph User [사용자 에이전트 A]
      U[사용자]

      subgraph Layer1 [클라이언트 도메인 A]
        A[클라이언트 애플리케이션 A]
      end

      subgraph Layer1 [클라이언트 도메인 B]
        B[클라이언트 애플리케이션 B]
      end

      subgraph Layer2 [Logto 도메인]
          C{{Logto 로그인 세션?}}
          D[로그인 페이지]
      end
    end

    U --> |로그인| A
    A --> |Logto로 리디렉션| C
    U --> |로그인| B
    B --> |Logto로 리디렉션| C
    C --> |아니오| D
    D --> |세션 생성| C
   ```

2. 분리된 Logto 세션 쿠키
   다른 장치나 브라우저에서 다른 클라이언트 애플리케이션에 로그인하는 사용자는 Logto 도메인 아래에 분리된 세션 쿠키를 갖게 됩니다. 이는 사용자가 각 클라이언트 애플리케이션에 별도로 로그인해야 함을 의미합니다.

   ```mermaid
    flowchart TD
    U[사용자]

    subgraph DeviceA [사용자 에이전트 A]
      subgraph Layer1 [클라이언트 도메인 A]
        A[클라이언트 애플리케이션 A]
      end

      subgraph Layer2 [Logto 도메인]
          C{{Logto 로그인 세션?}}
          D[로그인 페이지]
      end
    end

    subgraph DeviceB [사용자 에이전트 B]
      subgraph Layer3 [클라이언트 도메인 B]
        B[클라이언트 애플리케이션 B]
      end

      subgraph Layer4 [Logto 도메인]
          E{{Logto 로그인 세션?}}
          F[로그인 페이지]
      end
    end

    U --> |로그인| A
    A --> |Logto로 리디렉션| C
    U --> |로그인| B
    B --> |Logto로 리디렉션| E
    C --> |아니오| D
    E --> |아니오| F
    D --> |세션 생성| C
    F --> |세션 생성| E
   ```

## 클라이언트 애플리케이션이 관리하는 분산된 인증 상태 \{#distributed-authentication-status-managed-by-the-client-applications}

각 클라이언트 애플리케이션은 자체 인증 상태를 유지합니다. 네이티브, SPA, 웹 애플리케이션 모두 사용자의 인증 상태를 관리하는 고유한 방법을 가지고 있습니다.

성공적으로 로그인하면 클라이언트 애플리케이션은 [ID 토큰](https://auth.wiki/id-token)과 [액세스 토큰](https://auth.wiki/access-token)을 받을 수 있습니다. 클라이언트 애플리케이션은 ID 토큰을 사용하여 사용자의 아이덴티티를 확인하고 액세스 토큰을 사용하여 사용자의 리소스에 접근할 수 있습니다. 사용자의 인증 상태는 액세스 토큰의 만료 시간으로 표현됩니다.

- 네이티브 및 SPA 애플리케이션:
  클라이언트 애플리케이션은 사용자의 인증 상태를 유지하기 위해 이러한 토큰을 안전하게 저장하고 관리해야 합니다. 예를 들어, 로컬 스토리지나 세션 스토리지에 토큰을 저장하고 사용자가 로그아웃할 때 토큰을 삭제합니다.
- 웹 애플리케이션:
  Next.js와 같은 프레임워크로 구축된 웹 앱은 Logto에서 발급한 토큰과 함께 로그인한 사용자를 위한 자체 세션을 관리합니다. 사용자가 로그인하고 Logto에서 토큰을 받으면, SPA 애플리케이션처럼 클라이언트 측에 토큰을 저장하거나 서버 측에 토큰을 저장하고 쿠키 또는 다른 메커니즘을 사용하여 세션을 관리할 수 있습니다.

## 로그아웃 메커니즘 \{#sign-out-mechanisms}

### 클라이언트 측에서 토큰 및 로컬 세션 삭제 \{#clear-tokens-and-local-session-at-the-client-side}

클라이언트 측에서는 간단한 로그아웃이 로컬 세션을 삭제하고 로컬 스토리지나 세션 스토리지에서 토큰 (ID 토큰, 액세스 토큰, 리프레시 토큰)을 제거하는 것을 포함합니다. 이는 클라이언트 측에서만 로그아웃이 이루어지며 중앙화된 세션은 그대로 남아 있습니다. 이러한 방식으로 로그아웃한 사용자는 중앙화된 세션이 만료되거나 적극적으로 파괴될 때까지 동일한 인가 서버 세션 아래의 다른 애플리케이션에 여전히 접근할 수 있습니다.

### Logto에서 로그인 세션 삭제 \{#clear-sign-in-session-at-logto}

사용자를 명시적으로 로그아웃하고 Logto에서 세션을 삭제하려면, 클라이언트 애플리케이션이 사용자를 Logto의 **세션 종료 엔드포인트**로 리디렉션해야 합니다.

예: `https://{your-logto-domain}/oidc/session/end`

**세션 종료 엔드포인트**는 클라이언트 애플리케이션이 사용자가 로그아웃했음을 인가 서버에 알릴 수 있는 표준 OIDC 엔드포인트입니다. 이 엔드포인트는 Logto에서 중앙화된 로그인 세션을 삭제합니다.

세션이 삭제되면, 이후의 모든 인가 요청은 사용자가 다시 로그인해야 합니다.

**로그아웃 후 리디렉션 URI**가 제공되면, 세션이 삭제된 후 사용자가 지정된 URI로 리디렉션됩니다. 그렇지 않으면, 사용자는 Logto에서 호스팅하는 기본 로그아웃 후 페이지로 리디렉션됩니다.

## 연합 로그아웃: 백채널 로그아웃 \{#federated-sign-out-back-channel-logout}

보다 일관된 로그아웃 관리를 위해, Logto는 [백채널 로그아웃](https://openid.net/specs/openid-connect-backchannel-1_0-final.html)을 지원합니다. 백채널 로그아웃은 사용자가 로그아웃할 때 동일한 로그인 세션 아래의 모든 클라이언트 애플리케이션에 Logto가 알릴 수 있는 메커니즘입니다.

이는 사용자가 한 클라이언트 애플리케이션에서 로그아웃하고 동일한 Logto 로그인 세션 아래의 모든 다른 클라이언트 애플리케이션에서도 로그아웃되기를 기대하는 시나리오에서 특히 유용합니다.

클라이언트 애플리케이션에 대해 백채널 로그아웃을 활성화하려면, Logto 대시보드의 애플리케이션 세부 정보 페이지로 이동하여 백채널 로그아웃 URI를 등록하세요. 사용자가 어떤 클라이언트 애플리케이션에서 로그아웃 요청을 시작하면 Logto는 등록된 모든 URI에 로그아웃 토큰을 보냅니다.

클라이언트 애플리케이션이 로그아웃 토큰에 로그인 세션이 포함되기를 요구하는 경우, 백채널 로그아웃 구성에서 `세션 필요 여부` 설정을 켜세요. Logto에서 사용자의 로그인 세션을 식별하기 위해 로그아웃 토큰에 `sid` 클레임이 포함됩니다.

1. 사용자가 한 클라이언트 애플리케이션에서 로그아웃 요청을 시작합니다.
2. Logto가 세션 종료 요청을 받고 로그아웃 토큰을 생성하여 등록된 모든 백채널 로그아웃 URI에 로그아웃 토큰을 보냅니다.
3. 각 클라이언트 애플리케이션이 로그아웃 토큰을 받고 로그아웃 작업을 수행합니다.

클라이언트 애플리케이션이 로그아웃 토큰을 받을 때 수행하는 로그아웃 작업:

- 로그아웃 토큰을 검증합니다.
- 로컬 세션을 삭제하고 로컬 스토리지나 세션 스토리지에서 토큰을 제거합니다.

## Logto SDK에서의 로그아웃 방법 \{#sign-out-methods-in-logto-sdks}

Logto의 SDK를 사용하여 클라이언트 애플리케이션과 Logto를 통합하는 경우:

- SPA 및 웹 애플리케이션의 경우, `client.signOut()` 메서드는 로컬 토큰 저장소를 삭제하고 사용자를 Logto의 세션 종료 엔드포인트로 리디렉션합니다. 세션이 삭제된 후 사용자를 리디렉션할 **로그아웃 후 리디렉션 URI**를 지정할 수 있습니다.
- 네이티브 애플리케이션 (React Native 및 Flutter와 같은 하이브리드 앱 포함)의 경우, 로컬 토큰 저장소만 삭제됩니다. 이는 네이티브 애플리케이션에서 세션 없는 웹뷰를 사용하여 로그인 프로세스를 처리하기 때문입니다. 네이티브 브라우저에 세션 쿠키가 저장되지 않으므로 Logto에서 로그인 세션을 삭제할 필요가 없습니다. 각 인증 요청은 세션 쿠키를 포함하지 않는 독립적인 요청입니다.

:::note
세션 없는 웹뷰를 지원하지 않거나 `강조된` 설정을 인식하지 않는 네이티브 애플리케이션 (React Native 또는 Flutter SDK를 사용하는 Android 앱)의 경우, 인가 요청에 `prompt=login` 매개변수를 전달하여 사용자가 다시 로그인하도록 강제할 수 있습니다.
:::

## 자주 묻는 질문 \{#faqs}

<details>
  <summary>

### 백채널 로그아웃 알림을 받지 못하고 있습니다. \{#im-not-receiving-the-back-channel-logout-notifications}

</summary>

- Logto 대시보드에 백채널 로그아웃 URI가 올바르게 등록되어 있는지 확인하세요.
- 클라이언트 애플리케이션에 유효한 활성 로그인 세션이 있으며 로그아웃 요청을 시작한 세션과 동일한 세션인지 확인하세요.

</details>

## 관련 리소스 \{#related-resources}

<Url href="https://blog.logto.io/oidc-back-channel-logout/">OIDC 백채널 로그아웃 이해하기.</Url>
