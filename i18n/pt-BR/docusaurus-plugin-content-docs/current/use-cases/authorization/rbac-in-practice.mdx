---
sidebar_position: 1
sidebar_label: RBAC na pr√°tica
description: 'Um guia pr√°tico para controle de acesso baseado em papel (RBAC): Aprenda como projetar permiss√µes, gerenciar pap√©is e configurar autoriza√ß√£o segura em seu CMS.'
---

<head>
  <link rel="canonical" href="https://blog.logto.io/rbac-in-practice" />
</head>

# RBAC na pr√°tica: Implementando autoriza√ß√£o segura para seu aplicativo

Voc√™ est√° tendo dificuldades para implementar um sistema de autoriza√ß√£o seguro e escal√°vel para seu aplicativo? O Controle de Acesso Baseado em Papel (RBAC) √© o padr√£o da ind√∫stria para gerenciar permiss√µes de usu√°rios, mas implement√°-lo corretamente pode ser desafiador. Este tutorial mostrar√° como construir um sistema RBAC robusto usando um exemplo real de Sistema de Gerenciamento de Conte√∫do (CMS).

Ao seguir este guia, voc√™ aprender√°:

- ‚ú® Como projetar e implementar permiss√µes granulares que oferecem controle preciso
- üîí Melhores pr√°ticas para organizar permiss√µes em pap√©is significativos
- üë§ T√©cnicas para lidar com propriedade de recursos de forma eficaz
- üöÄ Maneiras de tornar seu sistema de autoriza√ß√£o escal√°vel e f√°cil de manter
- üí° Implementa√ß√£o pr√°tica usando um exemplo real de CMS

O c√≥digo-fonte completo deste tutorial est√° dispon√≠vel no [GitHub](https://github.com/logto-io/rbac-sample).

## Compreendendo os fundamentos do RBAC \{#understanding-rbac-fundamentals}

O Controle de Acesso Baseado em Papel √© mais do que apenas atribuir permiss√µes a usu√°rios. Trata-se de criar uma abordagem estruturada para autoriza√ß√£o (Authorization) que equilibra seguran√ßa com facilidade de manuten√ß√£o.

Voc√™ pode saber mais sobre [O que √© RBAC](https://auth-wiki.logto.io/rbac) na Auth Wiki.

Aqui est√£o os princ√≠pios-chave que seguiremos em nossa implementa√ß√£o:

### Design de permiss√µes granulares \{#fine-grained-permission-design}

Permiss√µes granulares oferecem controle preciso sobre o que os usu√°rios podem fazer em seu sistema. Em vez de n√≠veis amplos de acesso como "admin" ou "usu√°rio", definimos a√ß√µes espec√≠ficas que os usu√°rios podem realizar em recursos. Por exemplo:

- `read:articles` - Visualizar qualquer artigo no sistema
- `create:articles` - Criar novos artigos
- `update:articles` - Modificar artigos existentes
- `publish:articles` - Alterar o status de publica√ß√£o dos artigos

### Propriedade de recursos e controle de acesso \{#resource-ownership-and-access-control}

A propriedade de recursos √© um conceito fundamental no design de autoriza√ß√£o (Authorization) do nosso CMS. Enquanto o RBAC define quais a√ß√µes diferentes pap√©is podem executar, a propriedade adiciona uma dimens√£o pessoal ao controle de acesso:

- Autores t√™m acesso automaticamente aos artigos que criaram
- Esse modelo de propriedade natural significa que autores sempre podem visualizar e editar seu pr√≥prio conte√∫do
- O sistema verifica tanto as permiss√µes do papel OU a propriedade ao lidar com opera√ß√µes de artigos
- Por exemplo, mesmo sem a permiss√£o `update:articles`, um autor ainda pode editar seus pr√≥prios artigos
- Esse design reduz a necessidade de permiss√µes extras de papel, mantendo a seguran√ßa

Essa abordagem de duas camadas (pap√©is + propriedade) cria um sistema mais intuitivo e seguro. Editores e administradores ainda podem gerenciar todo o conte√∫do atrav√©s das permiss√µes de seus pap√©is, enquanto autores mant√™m o controle sobre seu pr√≥prio trabalho.

## Projetando APIs seguras \{#designing-a-secure-apis}

Vamos come√ßar projetando a funcionalidade principal do nosso CMS atrav√©s de seus endpoints de API:

```
GET    /api/articles         # Listar todos os artigos
GET    /api/articles/:id     # Obter um artigo espec√≠fico
POST   /api/articles         # Criar um novo artigo
PATCH  /api/articles/:id     # Atualizar um artigo
DELETE /api/articles/:id     # Excluir um artigo
PATCH  /api/articles/:id/published  # Alterar status de publica√ß√£o
```

### Implemente controle de acesso para sua API \{#implement-access-control-for-your-api}

Para cada endpoint, precisamos considerar dois aspectos do controle de acesso:

1. Propriedade do recurso - O usu√°rio √© dono deste recurso?
2. Permiss√µes baseadas em papel - O papel do usu√°rio permite esta opera√ß√£o?

Veja como lidaremos com o acesso para cada endpoint:

| Endpoint                          | L√≥gica de controle de acesso                                                            |
| --------------------------------- | --------------------------------------------------------------------------------------- |
| GET /api/articles                 | - Qualquer um com permiss√£o `list:articles`, OU autores podem ver seus pr√≥prios artigos |
| GET /api/articles/:id             | - Qualquer um com permiss√£o `read:articles`, OU autor do artigo                         |
| POST /api/articles                | - Qualquer um com permiss√£o `create:articles`                                           |
| PATCH /api/articles/:id           | - Qualquer um com permiss√£o `update:articles`, OU autor do artigo                       |
| DELETE /api/articles/:id          | - Qualquer um com permiss√£o `delete:articles`, OU autor do artigo                       |
| PATCH /api/articles/:id/published | - Apenas usu√°rios com permiss√£o `publish:articles`                                      |

### Criando um sistema de permiss√µes escal√°vel \{#creating-a-permission-system-that-scales}

Com base nos requisitos de acesso √† API, podemos definir estas permiss√µes:

| Permiss√£o        | Descri√ß√£o                                         |
| ---------------- | ------------------------------------------------- |
| list:articles    | Visualizar a lista de todos os artigos no sistema |
| read:articles    | Ler o conte√∫do completo de qualquer artigo        |
| create:articles  | Criar novos artigos                               |
| update:articles  | Modificar qualquer artigo                         |
| delete:articles  | Excluir qualquer artigo                           |
| publish:articles | Alterar status de publica√ß√£o                      |

Observe que essas permiss√µes s√≥ s√£o necess√°rias ao acessar recursos que voc√™ n√£o possui. Os propriet√°rios dos artigos podem automaticamente:

- Visualizar seus pr√≥prios artigos (n√£o precisa de `read:articles`)
- Editar seus pr√≥prios artigos (n√£o precisa de `update:articles`)
- Excluir seus pr√≥prios artigos (n√£o precisa de `delete:articles`)

## Construindo pap√©is eficazes \{#building-effective-roles}

Agora que temos nossa API e permiss√µes definidas, podemos criar pap√©is que agrupam essas permiss√µes logicamente:

| Permiss√£o/Papel  | üëë Admin                                            | üìù Publisher                                     | ‚úçÔ∏è Author                           |
| ---------------- | --------------------------------------------------- | ------------------------------------------------ | ----------------------------------- |
| **Descri√ß√£o**    | Acesso total ao sistema para gerenciamento completo | Pode ver todos os artigos e controlar publica√ß√£o | Pode criar novos artigos no sistema |
| list:articles    | ‚úÖ                                                  | ‚úÖ                                               | ‚ùå                                  |
| read:articles    | ‚úÖ                                                  | ‚úÖ                                               | ‚ùå                                  |
| create:articles  | ‚úÖ                                                  | ‚ùå                                               | ‚úÖ                                  |
| update:articles  | ‚úÖ                                                  | ‚ùå                                               | ‚ùå                                  |
| delete:articles  | ‚úÖ                                                  | ‚ùå                                               | ‚ùå                                  |
| publish:articles | ‚úÖ                                                  | ‚úÖ                                               | ‚ùå                                  |

**Nota**: Autores t√™m automaticamente permiss√µes de leitura/atualiza√ß√£o/exclus√£o para seus pr√≥prios artigos, independentemente das permiss√µes do papel.

Cada papel √© projetado com responsabilidades espec√≠ficas em mente:

- **Admin**: Tem controle total sobre o CMS, incluindo todas as opera√ß√µes de artigos
- **Publisher**: Foca na revis√£o de conte√∫do e gerenciamento de publica√ß√£o
- **Author**: Especialista em cria√ß√£o de conte√∫do

Essa estrutura de pap√©is cria uma separa√ß√£o clara de responsabilidades:

- Autores focam na cria√ß√£o de conte√∫do
- Publishers gerenciam a qualidade e visibilidade do conte√∫do
- Admins mant√™m o controle geral do sistema

## Configurando RBAC no Logto \{#config-rbac-in-logto}

Antes de come√ßar, voc√™ precisa criar uma conta no [Logto Cloud](https://cloud.logto.io), ou voc√™ tamb√©m pode usar uma inst√¢ncia Logto auto-hospedada usando a [vers√£o Logto OSS](/logto-oss).

Mas para este tutorial, usaremos o Logto Cloud pela simplicidade.

### Configurando seu aplicativo \{#setting-up-your-application}

1. V√° em "Applications" no Logto Console para criar um novo aplicativo react
   - Nome do aplicativo: Sistema de Gerenciamento de Conte√∫do
   - Tipo de aplicativo: Aplicativo Web Tradicional
   - URIs de redirecionamento: http://localhost:5173/callback

![Aplicativo CMS React](https://uploads.strapi.logto.io/cms_application_3ed42f2256.png)

### Configurando recursos de API e permiss√µes \{#configuring-api-resources-and-permissions}

1. V√° em "API Resources" no Logto Console para criar um novo recurso de API
   - Nome da API: CMS API
   - Identificador da API: https://api.cms.com
   - Adicione permiss√µes ao recurso de API
     - `list:articles`
     - `read:articles`
     - `create:articles`
     - `update:articles`
     - `publish:articles`
     - `delete:articles`

![Detalhes do recurso CMS API](https://uploads.strapi.logto.io/cms_api_resource_b15ae2b91a.png)

### Criando pap√©is \{#creating-roles}

V√° em Roles no Logto Console para criar os seguintes pap√©is para o CMS

- Admin
  - com todas as permiss√µes
- Publisher
  - com `read:articles`, `list:articles`, `publish:articles`
- Author
  - com `create:articles`

![Papel Admin](https://uploads.strapi.logto.io/admin_role_53edb35ecf.png)

![Papel Publisher](https://uploads.strapi.logto.io/publisher_role_2ac205cc32.png)

![Papel Author](https://uploads.strapi.logto.io/author_role_f89cd99543.png)

### Atribuindo pap√©is aos usu√°rios \{#assigning-roles-to-users}

V√° at√© a se√ß√£o "User management" no Logto Console para criar usu√°rios.

Na aba "Roles" dos detalhes do usu√°rio, voc√™ pode atribuir pap√©is ao usu√°rio.

No nosso exemplo, criamos 3 usu√°rios com os seguintes pap√©is:

- Alex: Admin
- Bob: Publisher
- Charlie: Author

![Gerenciamento de usu√°rios](https://uploads.strapi.logto.io/user_management_c0bc17119f.png)

![Detalhes do usu√°rio - Alex](https://uploads.strapi.logto.io/user_details_alex_702f96ef9a.png)

:::note
Para fins de demonstra√ß√£o, criamos esses recursos e configura√ß√µes pelo Logto Console. Em projetos reais, voc√™ pode criar esses recursos e configura√ß√µes programaticamente usando a [Management API](/integrate-logto/interact-with-management-api) fornecida pelo Logto.
:::

## Integre seu frontend com o RBAC do Logto \{#integrate-your-frontend-with-logto-rbac}

Agora que configuramos o RBAC no Logto, podemos come√ßar a integr√°-lo ao nosso frontend.

Primeiro, siga os [Logto Quick Starts](/quick-starts) para integrar o Logto ao seu aplicativo.

No nosso exemplo, usamos [React](/quick-starts/react) para demonstra√ß√£o.

Depois de configurar o Logto em seu aplicativo, precisamos adicionar as configura√ß√µes de RBAC para o Logto funcionar.

```tsx
// frontend/src/App.tsx

const logtoConfig: LogtoConfig = {
  appId: LOGTO_APP_ID, // O app ID que voc√™ criou no Logto Console
  endpoint: LOGTO_ENDPOINT, // O endpoint que voc√™ criou no Logto Console
  resources: [API_RESOURCE], // O identificador do recurso de API que voc√™ criou no Logto Console, ex: https://api.cms.com
  // Todos os escopos que voc√™ pode querer solicitar do recurso de API no frontend
  scopes: [
    'list:articles',
    'create:articles',
    'read:articles',
    'update:articles',
    'delete:articles',
    'publish:articles',
  ],
};
```

Lembre-se de sair e entrar novamente para que essa altera√ß√£o tenha efeito se voc√™ j√° estiver autenticado.

Quando o usu√°rio faz login com o Logto e solicita um token de acesso para os recursos de API especificados acima, o Logto adicionar√° escopos (permiss√µes) relacionados ao papel do usu√°rio ao token de acesso.

Voc√™ pode usar `getAccessTokenClaims` do hook `useLogto` para obter os escopos do token de acesso.

```tsx
// frontend/src/hooks/use-user-data.ts

import { useLogto } from '@logto/react';
import { API_RESOURCE } from '../config';
import { useState, useEffect } from 'react';

export const useUserData = () => {
  const { getAccessTokenClaims } = useLogto();
  const [userScopes, setUserScopes] = useState<string[]>([]);
  const [userId, setUserId] = useState<string>();

  useEffect(() => {
    const fetchScopes = async () => {
      const token = await getAccessTokenClaims(API_RESOURCE);
      setUserScopes(token?.scope?.split(' ') ?? []);
      setUserId(token?.sub);
    };

    fetchScopes();
  }, [getAccessTokenClaims]);

  return { userId, userScopes };
};
```

E voc√™ pode usar o `userScopes` para verificar se o usu√°rio tem permiss√£o para acessar o recurso.

```tsx
// frontend/src/pages/Dashboard.tsx

const Dashboard = () => {
  const { userId, userScopes } = useUserData();
  // ...

  return (
    <div>
      {/* ... */}
      {(userScopes.includes('delete:articles') || article.ownerId === userId) && (
        <button
          onClick={() => handleDelete(article.id)}
          className="text-red-600 hover:text-red-900"
        >
          Delete
        </button>
      )}
    </div>
  );
};
```

## Integre seu backend com o RBAC do Logto \{#integrate-your-backend-with-logto-rbac}

Agora, √© hora de integrar o RBAC do Logto ao seu backend.

### Middleware de autoriza√ß√£o no backend \{#backend-authorization-middleware}

Primeiro, precisamos adicionar um middleware no backend para verificar as permiss√µes do usu√°rio, conferir se o usu√°rio est√° autenticado e determinar se ele tem as permiss√µes necess√°rias para acessar certas APIs.

```javascript
// backend/src/middleware/auth.js

const { createRemoteJWKSet, jwtVerify } = require('jose');

const getTokenFromHeader = (headers) => {
  const { authorization } = headers;
  const bearerTokenIdentifier = 'Bearer';

  if (!authorization) {
    throw new Error('Authorization header missing');
  }

  if (!authorization.startsWith(bearerTokenIdentifier)) {
    throw new Error('Authorization token type not supported');
  }

  return authorization.slice(bearerTokenIdentifier.length + 1);
};

const hasScopes = (tokenScopes, requiredScopes) => {
  if (!requiredScopes || requiredScopes.length === 0) {
    return true;
  }
  const scopeSet = new Set(tokenScopes);
  return requiredScopes.every((scope) => scopeSet.has(scope));
};

const verifyJwt = async (token) => {
  const JWKS = createRemoteJWKSet(new URL(process.env.LOGTO_JWKS_URL));

  const { payload } = await jwtVerify(token, JWKS, {
    issuer: process.env.LOGTO_ISSUER,
    audience: process.env.LOGTO_API_RESOURCE,
  });

  return payload;
};

const requireAuth = (requiredScopes = []) => {
  return async (req, res, next) => {
    try {
      // Extrair o token
      const token = getTokenFromHeader(req.headers);

      // Verificar o token
      const payload = await verifyJwt(token);

      // Adicionar informa√ß√µes do usu√°rio √† requisi√ß√£o
      req.user = {
        id: payload.sub,
        scopes: payload.scope?.split(' ') || [],
      };

      // Verificar escopos necess√°rios
      if (!hasScopes(req.user.scopes, requiredScopes)) {
        throw new Error('Insufficient permissions');
      }

      next();
    } catch (error) {
      res.status(401).json({ error: 'Unauthorized' });
    }
  };
};

module.exports = {
  requireAuth,
  hasScopes,
};
```

Como voc√™ pode ver, neste middleware, verificamos se a requisi√ß√£o do frontend cont√©m um token de acesso v√°lido e se o p√∫blico do token de acesso corresponde ao recurso de API que criamos no Logto Console.

O motivo de verificar o recurso de API √© que nosso recurso de API representa, na verdade, os recursos do backend do nosso CMS, e todas as permiss√µes do nosso CMS est√£o associadas a esse recurso de API.

Como esse recurso de API representa os recursos do CMS no Logto, em nosso c√≥digo frontend, inclu√≠mos o respectivo token de acesso ao fazer requisi√ß√µes de API para o backend:

```typescript
// frontend/src/hooks/use-api.ts
export const useApi = () => {
  const { getAccessToken } = useLogto();

  return useMemo(
    () =>
      async (endpoint: string, options: RequestInit = {}) => {
        try {
          // Obter o token de acesso para o recurso de API
          const token = await getAccessToken(API_RESOURCE);

          if (!token) {
            throw new ApiRequestError('Failed to get access token');
          }

          const response = await fetch(`${API_BASE_URL}${endpoint}`, {
            ...options,
            headers: {
              'Content-Type': 'application/json',
              // Adicionar o token de acesso ao cabe√ßalho da requisi√ß√£o
              Authorization: `Bearer ${token}`,
              ...options.headers,
            },
          });

          // ... tratar resposta

          return await response.json();
        } catch (error) {
          // ... tratamento de erro
        }
      },
    [getAccessToken]
  );
};
```

Agora podemos usar o middleware `requireAuth` para proteger nossos endpoints de API.

### Protegendo endpoints de API \{#protecting-api-endpoints}

Para APIs que s√≥ devem ser acess√≠veis a usu√°rios com permiss√µes espec√≠ficas, podemos adicionar restri√ß√µes diretamente no middleware. Por exemplo, a API de cria√ß√£o de artigo s√≥ deve ser acess√≠vel a usu√°rios com a permiss√£o `create:articles`:

```javascript
// backend/src/routes/articles.js

const { requireAuth } = require('../middleware/auth');

router.post('/articles', requireAuth(['create:articles']), async (req, res) => {
  // ...
});
```

Para APIs que precisam verificar tanto permiss√µes quanto propriedade do recurso, podemos usar a fun√ß√£o `hasScopes`. Por exemplo, na API de listagem de artigos, usu√°rios com o escopo `list:articles` podem acessar todos os artigos, enquanto autores podem acessar apenas os artigos que criaram:

```javascript
// backend/src/routes/articles.js

const { requireAuth, hasScopes } = require('../middleware/auth');

router.get('/articles', requireAuth(), async (req, res) => {
  try {
    // Se o usu√°rio tem o escopo list:articles, retorna todos os artigos
    if (hasScopes(req.user.scopes, ['list:articles'])) {
      const articles = await articleDB.list();
      return res.json(articles);
    }

    // Caso contr√°rio, retorna apenas os artigos do usu√°rio
    const articles = await articleDB.listByOwner(req.user.id);
    res.json(articles);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch articles' });
  }
});
```

Neste ponto, conclu√≠mos a implementa√ß√£o do RBAC. Voc√™ pode conferir [o c√≥digo-fonte completo](https://github.com/logto-io/rbac-sample) para ver a implementa√ß√£o completa.

## Testando a implementa√ß√£o do RBAC no CMS \{#test-the-cms-rbac-implementation}

Agora, vamos testar nossa implementa√ß√£o do RBAC no CMS usando os tr√™s usu√°rios que acabamos de criar.

:::note
Se voc√™ perceber que n√£o consegue fazer login com as credenciais dos usu√°rios criados em "User Management", ser√° necess√°rio habilitar primeiro o m√©todo de login apropriado. V√° em "Sign-in Experience" no Logto Console e habilite seu m√©todo de autentica√ß√£o preferido (como Email + Senha ou Nome de usu√°rio + Senha).
:::

Primeiro, vamos fazer login como Alex e Charles, respectivamente, e criar alguns artigos.

Como Alex tem o papel de Admin, ele pode criar, excluir, atualizar, publicar e visualizar todos os artigos.

![Painel do CMS - Alex](https://uploads.strapi.logto.io/cms_dashboard_alex_a11863a94b.png)

Charles, com o papel de Author, s√≥ pode criar seus pr√≥prios artigos e s√≥ pode visualizar, atualizar e excluir artigos que possui.

![Painel do CMS - Charles - Lista de artigos](https://uploads.strapi.logto.io/cms_dashboard_charles_05f610066a.png)

Bob, com o papel de Publisher, pode visualizar e publicar todos os artigos, mas n√£o pode criar, atualizar ou excluir.

![Painel do CMS - Bob](https://uploads.strapi.logto.io/cms_dashboard_bob_421a429b69.png)

## Conclus√£o \{#conclusion}

Parab√©ns! Voc√™ aprendeu como implementar um sistema RBAC robusto em seu aplicativo.

Para cen√°rios mais complexos, como construir aplicativos multi-inquilino, o Logto oferece suporte abrangente a organiza√ß√µes. Confira nosso guia [Construa um aplicativo SaaS multi-inquilino: Um guia completo do design √† implementa√ß√£o](https://blog.logto.io/build-multi-tenant-saas-application) para saber mais sobre como implementar controle de acesso em toda a organiza√ß√£o.

Boas codifica√ß√µes! üöÄ
