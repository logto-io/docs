---
sidebar_position: 1
sidebar_label: RBAC en pratique
description: 'Un guide pratique du contr√¥le d‚Äôacc√®s bas√© sur les r√¥les (RBAC) : Apprenez √† concevoir des permissions, g√©rer des r√¥les et mettre en place une autorisation s√©curis√©e dans votre CMS.'
---

<head>
  <link rel="canonical" href="https://blog.logto.io/rbac-in-practice" />
</head>

# RBAC en pratique : Mettre en ≈ìuvre une autorisation s√©curis√©e pour votre application

Vous avez du mal √† mettre en place un syst√®me d'autorisation s√©curis√© et √©volutif pour votre application ? Le contr√¥le d‚Äôacc√®s bas√© sur les r√¥les (RBAC) est la norme de l'industrie pour la gestion des permissions utilisateur, mais sa mise en ≈ìuvre correcte peut √™tre un d√©fi. Ce tutoriel vous montrera comment construire un syst√®me RBAC robuste √† l'aide d'un exemple concret de syst√®me de gestion de contenu (CMS).

En suivant ce guide, vous apprendrez :

- ‚ú® Comment concevoir et mettre en ≈ìuvre des permissions granulaires pour un contr√¥le pr√©cis
- üîí Les meilleures pratiques pour organiser les permissions en r√¥les significatifs
- üë§ Des techniques pour g√©rer efficacement la propri√©t√© des ressources
- üöÄ Des m√©thodes pour rendre votre syst√®me d‚Äôautorisation √©volutif et maintenable
- üí° Une mise en ≈ìuvre pratique √† l‚Äôaide d‚Äôun exemple r√©el de CMS

Le code source complet de ce tutoriel est disponible sur [GitHub](https://github.com/logto-io/rbac-sample).

## Comprendre les fondamentaux du RBAC \{#understanding-rbac-fundamentals}

Le contr√¥le d‚Äôacc√®s bas√© sur les r√¥les ne consiste pas seulement √† attribuer des permissions aux utilisateurs. Il s'agit de cr√©er une approche structur√©e de l'autorisation qui √©quilibre s√©curit√© et maintenabilit√©.

Vous pouvez en apprendre plus sur [Qu‚Äôest-ce que le RBAC](https://auth-wiki.logto.io/rbac) dans l‚ÄôAuth Wiki.

Voici les principes cl√©s que nous suivrons dans notre mise en ≈ìuvre :

### Conception de permissions granulaires \{#fine-grained-permission-design}

Des permissions granulaires vous donnent un contr√¥le pr√©cis sur ce que les utilisateurs peuvent faire dans votre syst√®me. Au lieu de niveaux d'acc√®s larges comme "admin" ou "utilisateur", nous d√©finissons des actions sp√©cifiques que les utilisateurs peuvent effectuer sur les ressources. Par exemple :

- `read:articles` - Voir n'importe quel article du syst√®me
- `create:articles` - Cr√©er de nouveaux articles
- `update:articles` - Modifier des articles existants
- `publish:articles` - Changer le statut de publication des articles

### Propri√©t√© des ressources et contr√¥le d‚Äôacc√®s \{#resource-ownership-and-access-control}

La propri√©t√© des ressources est un concept fondamental dans la conception de l'autorisation de notre CMS. Alors que le RBAC d√©finit quelles actions diff√©rents r√¥les peuvent effectuer, la propri√©t√© ajoute une dimension personnelle au contr√¥le d'acc√®s :

- Les auteurs ont automatiquement acc√®s aux articles qu'ils ont cr√©√©s
- Ce mod√®le naturel de propri√©t√© signifie que les auteurs peuvent toujours voir et √©diter leur propre contenu
- Le syst√®me v√©rifie √† la fois les permissions de r√¥le OU la propri√©t√© lors du traitement des op√©rations sur les articles
- Par exemple, m√™me sans la permission `update:articles`, un auteur peut toujours modifier ses propres articles
- Cette conception r√©duit le besoin de permissions suppl√©mentaires tout en maintenant la s√©curit√©

Cette approche √† double couche (r√¥les + propri√©t√©) cr√©e un syst√®me plus intuitif et s√©curis√©. Les √©diteurs et les administrateurs peuvent toujours g√©rer tout le contenu via leurs permissions de r√¥le, tandis que les auteurs gardent le contr√¥le sur leur propre travail.

## Concevoir des API s√©curis√©es \{#designing-a-secure-apis}

Commen√ßons par concevoir la fonctionnalit√© principale de notre CMS via ses points de terminaison API :

```
GET    /api/articles         # Lister tous les articles
GET    /api/articles/:id     # Obtenir un article sp√©cifique
POST   /api/articles        # Cr√©er un nouvel article
PATCH  /api/articles/:id    # Mettre √† jour un article
DELETE /api/articles/:id    # Supprimer un article
PATCH  /api/articles/:id/published  # Changer le statut de publication
```

### Mettre en ≈ìuvre le contr√¥le d‚Äôacc√®s pour votre API \{#implement-access-control-for-your-api}

Pour chaque point de terminaison, nous devons consid√©rer deux aspects du contr√¥le d'acc√®s :

1. Propri√©t√© de la ressource - L'utilisateur poss√®de-t-il cette ressource ?
2. Permissions bas√©es sur les r√¥les - Le r√¥le de l'utilisateur autorise-t-il cette op√©ration ?

Voici comment nous g√©rerons l'acc√®s pour chaque point de terminaison :

| Endpoint                          | Logique de contr√¥le d‚Äôacc√®s                                                                       |
| --------------------------------- | ------------------------------------------------------------------------------------------------- |
| GET /api/articles                 | - Toute personne avec la permission `list:articles`, OU les auteurs voient leurs propres articles |
| GET /api/articles/:id             | - Toute personne avec la permission `read:articles`, OU auteur de l‚Äôarticle                       |
| POST /api/articles                | - Toute personne avec la permission `create:articles`                                             |
| PATCH /api/articles/:id           | - Toute personne avec la permission `update:articles`, OU auteur de l‚Äôarticle                     |
| DELETE /api/articles/:id          | - Toute personne avec la permission `delete:articles`, OU auteur de l‚Äôarticle                     |
| PATCH /api/articles/:id/published | - Seuls les utilisateurs avec la permission `publish:articles`                                    |

### Cr√©er un syst√®me de permissions √©volutif \{#creating-a-permission-system-that-scales}

En fonction des exigences d'acc√®s √† notre API, nous pouvons d√©finir ces permissions :

| Permission       | Description                                       |
| ---------------- | ------------------------------------------------- |
| list:articles    | Voir la liste de tous les articles du syst√®me     |
| read:articles    | Lire le contenu complet de n'importe quel article |
| create:articles  | Cr√©er de nouveaux articles                        |
| update:articles  | Modifier n'importe quel article                   |
| delete:articles  | Supprimer n'importe quel article                  |
| publish:articles | Changer le statut de publication                  |

Notez que ces permissions ne sont n√©cessaires que pour acc√©der aux ressources que vous ne poss√©dez pas. Les propri√©taires d‚Äôarticles peuvent automatiquement :

- Voir leurs propres articles (pas besoin de `read:articles`)
- Modifier leurs propres articles (pas besoin de `update:articles`)
- Supprimer leurs propres articles (pas besoin de `delete:articles`)

## Construire des r√¥les efficaces \{#building-effective-roles}

Maintenant que nous avons d√©fini notre API et nos permissions, nous pouvons cr√©er des r√¥les qui regroupent logiquement ces permissions :

| Permission/R√¥le  | üëë Admin                                            | üìù √âditeur                                          | ‚úçÔ∏è Auteur                                       |
| ---------------- | --------------------------------------------------- | --------------------------------------------------- | ----------------------------------------------- |
| **Description**  | Acc√®s complet au syst√®me pour la gestion du contenu | Peut voir tous les articles et g√©rer la publication | Peut cr√©er de nouveaux articles dans le syst√®me |
| list:articles    | ‚úÖ                                                  | ‚úÖ                                                  | ‚ùå                                              |
| read:articles    | ‚úÖ                                                  | ‚úÖ                                                  | ‚ùå                                              |
| create:articles  | ‚úÖ                                                  | ‚ùå                                                  | ‚úÖ                                              |
| update:articles  | ‚úÖ                                                  | ‚ùå                                                  | ‚ùå                                              |
| delete:articles  | ‚úÖ                                                  | ‚ùå                                                  | ‚ùå                                              |
| publish:articles | ‚úÖ                                                  | ‚úÖ                                                  | ‚ùå                                              |

**Remarque** : Les auteurs ont automatiquement les permissions de lecture / modification / suppression sur leurs propres articles, ind√©pendamment des permissions de r√¥le.

Chaque r√¥le est con√ßu avec des responsabilit√©s sp√©cifiques en t√™te :

- **Admin** : A un contr√¥le total sur le CMS, y compris toutes les op√©rations sur les articles
- **√âditeur** : Se concentre sur la relecture du contenu et la gestion de la publication
- **Auteur** : Sp√©cialis√© dans la cr√©ation de contenu

Cette structure de r√¥les cr√©e une s√©paration claire des responsabilit√©s :

- Les auteurs se concentrent sur la cr√©ation de contenu
- Les √©diteurs g√®rent la qualit√© et la visibilit√© du contenu
- Les administrateurs maintiennent le contr√¥le global du syst√®me

## Configurer le RBAC dans Logto \{#config-rbac-in-logto}

Avant de commencer, vous devez cr√©er un compte sur [Logto Cloud](https://cloud.logto.io), ou vous pouvez √©galement utiliser une instance Logto auto-h√©berg√©e en utilisant la [version Logto OSS](/logto-oss).

Mais pour ce tutoriel, nous utiliserons Logto Cloud pour plus de simplicit√©.

### Configuration de votre application \{#setting-up-your-application}

1. Allez dans "Applications" dans la Console Logto pour cr√©er une nouvelle application react
   - Nom de l‚Äôapplication : Content Management System
   - Type d‚Äôapplication : Application Web traditionnelle
   - URI de redirection : http://localhost:5173/callback

![Application React CMS](https://uploads.strapi.logto.io/cms_application_3ed42f2256.png)

### Configuration des ressources API et des permissions \{#configuring-api-resources-and-permissions}

1. Allez dans "Ressources API" dans la Console Logto pour cr√©er une nouvelle ressource API
   - Nom de l‚ÄôAPI : CMS API
   - Identifiant de l‚ÄôAPI : https://api.cms.com
   - Ajoutez les permissions √† la ressource API
     - `list:articles`
     - `read:articles`
     - `create:articles`
     - `update:articles`
     - `publish:articles`
     - `delete:articles`

![D√©tails de la ressource API CMS](https://uploads.strapi.logto.io/cms_api_resource_b15ae2b91a.png)

### Cr√©ation des r√¥les \{#creating-roles}

Allez dans R√¥les dans la Console Logto pour cr√©er les r√¥les suivants pour le CMS

- Admin
  - avec toutes les permissions
- √âditeur
  - avec `read:articles`, `list:articles`, `publish:articles`
- Auteur
  - avec `create:articles`

![R√¥le Admin](https://uploads.strapi.logto.io/admin_role_53edb35ecf.png)

![R√¥le √âditeur](https://uploads.strapi.logto.io/publisher_role_2ac205cc32.png)

![R√¥le Auteur](https://uploads.strapi.logto.io/author_role_f89cd99543.png)

### Attribution des r√¥les aux utilisateurs \{#assigning-roles-to-users}

Allez dans la section "Gestion des utilisateurs" dans la Console Logto pour cr√©er des utilisateurs.

Dans l‚Äôonglet "R√¥les" des d√©tails de l‚Äôutilisateur, vous pouvez attribuer des r√¥les √† l‚Äôutilisateur.

Dans notre exemple, nous cr√©ons 3 utilisateurs avec les r√¥les suivants :

- Alex : Admin
- Bob : √âditeur
- Charlie : Auteur

![Gestion des utilisateurs](https://uploads.strapi.logto.io/user_management_c0bc17119f.png)

![D√©tails utilisateur - Alex](https://uploads.strapi.logto.io/user_details_alex_702f96ef9a.png)

:::note
√Ä des fins de d√©monstration, nous cr√©ons ces ressources et configurations via la Console Logto. Dans des projets r√©els, vous pouvez cr√©er ces ressources et configurations de mani√®re programmatique en utilisant la [Management API](/integrate-logto/interact-with-management-api) fournie par Logto.
:::

## Int√©grer votre frontend avec le RBAC Logto \{#integrate-your-frontend-with-logto-rbac}

Maintenant que nous avons configur√© le RBAC dans Logto, nous pouvons commencer √† l‚Äôint√©grer dans notre frontend.

Commencez par suivre les [Logto Quick Starts](/quick-starts) pour int√©grer Logto dans votre application.

Dans notre exemple, nous utilisons [React](/quick-starts/react) pour la d√©monstration.

Apr√®s avoir configur√© Logto dans votre application, nous devons ajouter les configurations RBAC pour que Logto fonctionne.

```tsx
// frontend/src/App.tsx

const logtoConfig: LogtoConfig = {
  appId: LOGTO_APP_ID, // L‚ÄôID de l‚Äôapplication que vous avez cr√©√© dans la Console Logto
  endpoint: LOGTO_ENDPOINT, // L‚Äôendpoint que vous avez cr√©√© dans la Console Logto
  resources: [API_RESOURCE], // L‚Äôidentifiant de la ressource API que vous avez cr√©√© dans la Console Logto, ex. https://api.cms.com
  // Toutes les port√©es que vous souhaitez demander √† la ressource API dans le frontend
  scopes: [
    'list:articles',
    'create:articles',
    'read:articles',
    'update:articles',
    'delete:articles',
    'publish:articles',
  ],
};
```

N‚Äôoubliez pas de vous d√©connecter et de vous reconnecter pour que ce changement prenne effet si vous √™tes d√©j√† connect√©.

Lorsque l‚Äôutilisateur se connecte avec Logto et demande un jeton d‚Äôacc√®s pour les ressources API sp√©cifi√©es ci-dessus, Logto ajoutera les port√©es (permissions) li√©es au r√¥le de l‚Äôutilisateur dans le jeton d‚Äôacc√®s.

Vous pouvez utiliser `getAccessTokenClaims` du hook `useLogto` pour obtenir les port√©es √† partir du jeton d‚Äôacc√®s.

```tsx
// frontend/src/hooks/use-user-data.ts

import { useLogto } from '@logto/react';
import { API_RESOURCE } from '../config';
import { useState, useEffect } from 'react';

export const useUserData = () => {
  const { getAccessTokenClaims } = useLogto();
  const [userScopes, setUserScopes] = useState<string[]>([]);
  const [userId, setUserId] = useState<string>();

  useEffect(() => {
    const fetchScopes = async () => {
      const token = await getAccessTokenClaims(API_RESOURCE);
      setUserScopes(token?.scope?.split(' ') ?? []);
      setUserId(token?.sub);
    };

    fetchScopes();
  }, [getAccessTokenClaims]);

  return { userId, userScopes };
};
```

Et vous pouvez utiliser `userScopes` pour v√©rifier si l‚Äôutilisateur a la permission d‚Äôacc√©der √† la ressource.

```tsx
// frontend/src/pages/Dashboard.tsx

const Dashboard = () => {
  const { userId, userScopes } = useUserData();
  // ...

  return (
    <div>
      {/* ... */}
      {(userScopes.includes('delete:articles') || article.ownerId === userId) && (
        <button
          onClick={() => handleDelete(article.id)}
          className="text-red-600 hover:text-red-900"
        >
          Supprimer
        </button>
      )}
    </div>
  );
};
```

## Int√©grer votre backend avec le RBAC Logto \{#integrate-your-backend-with-logto-rbac}

Il est maintenant temps d‚Äôint√©grer le RBAC Logto dans votre backend.

### Middleware d‚Äôautorisation backend \{#backend-authorization-middleware}

Tout d‚Äôabord, nous devons ajouter un middleware dans le backend pour v√©rifier les permissions utilisateur, s‚Äôassurer que l‚Äôutilisateur est connect√© et d√©terminer s‚Äôil dispose des permissions n√©cessaires pour acc√©der √† certaines API.

```javascript
// backend/src/middleware/auth.js

const { createRemoteJWKSet, jwtVerify } = require('jose');

const getTokenFromHeader = (headers) => {
  const { authorization } = headers;
  const bearerTokenIdentifier = 'Bearer';

  if (!authorization) {
    throw new Error('Authorization header missing');
  }

  if (!authorization.startsWith(bearerTokenIdentifier)) {
    throw new Error('Authorization token type not supported');
  }

  return authorization.slice(bearerTokenIdentifier.length + 1);
};

const hasScopes = (tokenScopes, requiredScopes) => {
  if (!requiredScopes || requiredScopes.length === 0) {
    return true;
  }
  const scopeSet = new Set(tokenScopes);
  return requiredScopes.every((scope) => scopeSet.has(scope));
};

const verifyJwt = async (token) => {
  const JWKS = createRemoteJWKSet(new URL(process.env.LOGTO_JWKS_URL));

  const { payload } = await jwtVerify(token, JWKS, {
    issuer: process.env.LOGTO_ISSUER,
    audience: process.env.LOGTO_API_RESOURCE,
  });

  return payload;
};

const requireAuth = (requiredScopes = []) => {
  return async (req, res, next) => {
    try {
      // Extraire le jeton
      const token = getTokenFromHeader(req.headers);

      // V√©rifier le jeton
      const payload = await verifyJwt(token);

      // Ajouter les infos utilisateur √† la requ√™te
      req.user = {
        id: payload.sub,
        scopes: payload.scope?.split(' ') || [],
      };

      // V√©rifier les port√©es requises
      if (!hasScopes(req.user.scopes, requiredScopes)) {
        throw new Error('Insufficient permissions');
      }

      next();
    } catch (error) {
      res.status(401).json({ error: 'Unauthorized' });
    }
  };
};

module.exports = {
  requireAuth,
  hasScopes,
};
```

Comme vous pouvez le voir, dans ce middleware, nous v√©rifions si la requ√™te frontend contient un jeton d‚Äôacc√®s valide et si l‚Äôaudience du jeton d‚Äôacc√®s correspond √† la ressource API que nous avons cr√©√©e dans la Console Logto.

La raison de la v√©rification de la ressource API est que notre ressource API repr√©sente en r√©alit√© les ressources de notre backend CMS, et toutes nos permissions CMS sont associ√©es √† cette ressource API.

Puisque cette ressource API repr√©sente les ressources CMS dans Logto, dans notre code frontend, nous incluons le jeton d‚Äôacc√®s correspondant lors des requ√™tes API vers le backend :

```typescript
// frontend/src/hooks/use-api.ts
export const useApi = () => {
  const { getAccessToken } = useLogto();

  return useMemo(
    () =>
      async (endpoint: string, options: RequestInit = {}) => {
        try {
          // Obtenir le jeton d‚Äôacc√®s pour la ressource API
          const token = await getAccessToken(API_RESOURCE);

          if (!token) {
            throw new ApiRequestError('Failed to get access token');
          }

          const response = await fetch(`${API_BASE_URL}${endpoint}`, {
            ...options,
            headers: {
              'Content-Type': 'application/json',
              // Ajouter le jeton d‚Äôacc√®s dans les en-t√™tes de la requ√™te
              Authorization: `Bearer ${token}`,
              ...options.headers,
            },
          });

          // ... gestion de la r√©ponse

          return await response.json();
        } catch (error) {
          // ... gestion des erreurs
        }
      },
    [getAccessToken]
  );
};
```

Nous pouvons maintenant utiliser le middleware `requireAuth` pour prot√©ger nos points de terminaison API.

### Prot√©ger les points de terminaison API \{#protecting-api-endpoints}

Pour les API qui ne doivent √™tre accessibles qu‚Äôaux utilisateurs disposant de permissions sp√©cifiques, nous pouvons ajouter des restrictions directement dans le middleware. Par exemple, l‚ÄôAPI de cr√©ation d‚Äôarticle ne doit √™tre accessible qu‚Äôaux utilisateurs ayant la permission `create:articles` :

```javascript
// backend/src/routes/articles.js

const { requireAuth } = require('../middleware/auth');

router.post('/articles', requireAuth(['create:articles']), async (req, res) => {
  // ...
});
```

Pour les API qui doivent v√©rifier √† la fois les permissions et la propri√©t√© de la ressource, nous pouvons utiliser la fonction `hasScopes`. Par exemple, dans l‚ÄôAPI de liste des articles, les utilisateurs ayant la port√©e `list:articles` peuvent acc√©der √† tous les articles, tandis que les auteurs peuvent acc√©der √† leurs propres articles cr√©√©s :

```javascript
// backend/src/routes/articles.js

const { requireAuth, hasScopes } = require('../middleware/auth');

router.get('/articles', requireAuth(), async (req, res) => {
  try {
    // Si l‚Äôutilisateur a la port√©e list:articles, retourner tous les articles
    if (hasScopes(req.user.scopes, ['list:articles'])) {
      const articles = await articleDB.list();
      return res.json(articles);
    }

    // Sinon, retourner uniquement les articles de l‚Äôutilisateur
    const articles = await articleDB.listByOwner(req.user.id);
    res.json(articles);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch articles' });
  }
});
```

√Ä ce stade, nous avons termin√© la mise en ≈ìuvre du RBAC. Vous pouvez consulter [le code source complet](https://github.com/logto-io/rbac-sample) pour voir l‚Äôimpl√©mentation compl√®te.

## Tester la mise en ≈ìuvre du RBAC dans le CMS \{#test-the-cms-rbac-implementation}

Testons maintenant la mise en ≈ìuvre du RBAC dans notre CMS √† l‚Äôaide des trois utilisateurs que nous venons de cr√©er.

:::note
Si vous constatez que vous ne pouvez pas vous connecter avec les identifiants des utilisateurs cr√©√©s dans "Gestion des utilisateurs", vous devrez d‚Äôabord activer la m√©thode de connexion appropri√©e. Rendez-vous dans "Exp√©rience de connexion" dans la Console Logto et activez votre m√©thode d‚Äôauthentification pr√©f√©r√©e (par exemple Email + Mot de passe ou Nom d‚Äôutilisateur + Mot de passe).
:::

Commen√ßons par nous connecter en tant qu‚ÄôAlex et Charles respectivement et cr√©ons quelques articles.

Puisqu‚ÄôAlex a le r√¥le Admin, il peut cr√©er, supprimer, mettre √† jour, publier et voir tous les articles.

![Tableau de bord CMS - Alex](https://uploads.strapi.logto.io/cms_dashboard_alex_a11863a94b.png)

Charles, ayant le r√¥le Auteur, ne peut cr√©er que ses propres articles et ne peut voir, mettre √† jour et supprimer que les articles qu‚Äôil poss√®de.

![Tableau de bord CMS - Charles - Liste des articles](https://uploads.strapi.logto.io/cms_dashboard_charles_05f610066a.png)

Bob, avec le r√¥le √âditeur, peut voir et publier tous les articles mais ne peut ni les cr√©er, ni les mettre √† jour, ni les supprimer.

![Tableau de bord CMS - Bob](https://uploads.strapi.logto.io/cms_dashboard_bob_421a429b69.png)

## Conclusion \{#conclusion}

F√©licitations ! Vous avez appris √† mettre en ≈ìuvre un syst√®me RBAC robuste dans votre application.

Pour des sc√©narios plus complexes, comme la cr√©ation d‚Äôapplications multi-locataires, Logto offre un support complet des organisations. Consultez notre guide [Construire une application SaaS multi-locataires : Guide complet de la conception √† la mise en ≈ìuvre](https://blog.logto.io/build-multi-tenant-saas) pour en savoir plus sur la mise en place d‚Äôun contr√¥le d‚Äôacc√®s √† l‚Äô√©chelle de l‚Äôorganisation.

Bon code ! üöÄ
