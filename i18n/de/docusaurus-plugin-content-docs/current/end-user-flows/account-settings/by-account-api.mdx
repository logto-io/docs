---
description: Erfahre, wie du die Account API zur Verwaltung von Benutzern verwendest
sidebar_position: 1
---

# Kontoeinstellungen über Account API

## Was ist die Logto Account API \{#what-is-logto-account-api}

Die Logto Account API ist eine umfassende Sammlung von APIs, die Endbenutzern direkten API-Zugriff ermöglicht, ohne die Management API verwenden zu müssen. Hier die wichtigsten Punkte:

- Direkter Zugriff: Die Account API ermöglicht es Endbenutzern, direkt auf ihr eigenes Konto zuzugreifen und dieses zu verwalten, ohne dass die Management API zwischengeschaltet werden muss.
- Verwaltung von Benutzerprofilen und Identitäten: Benutzer können ihre Profile und Sicherheitseinstellungen vollständig verwalten, einschließlich der Möglichkeit, Identitätsinformationen wie E-Mail, Telefon und Passwort zu aktualisieren sowie soziale Verbindungen zu verwalten. MFA und SSO-Unterstützung folgen in Kürze.
- Globale Zugangskontrolle: Administratoren haben vollständige, globale Kontrolle über die Zugriffseinstellungen und können jedes Feld individuell anpassen.
- Nahtlose Autorisierung (Authorization): Autorisierung (Authorization) war noch nie so einfach! Verwende einfach `client.getAccessToken()`, um ein opakes Zugangstoken (Opaque token) für OP (Logto) zu erhalten, und füge es dem Authorization-Header als `Bearer <access_token>` hinzu.

:::note
Um sicherzustellen, dass das Zugangstoken (Access token) die entsprechenden Berechtigungen hat, stelle sicher, dass du die entsprechenden Berechtigungen (Scopes) in deiner Logto-Konfiguration korrekt eingerichtet hast.

Zum Beispiel musst du für die `POST /api/my-account/primary-email` API die Berechtigung (Scope) `email` konfigurieren; für die `POST /api/my-account/primary-phone` API die Berechtigung (Scope) `phone`.

```ts
import { type LogtoConfig, UserScope } from '@logto/js';

const config: LogtoConfig = {
  // ...andere Optionen
  // Füge die passenden Berechtigungen (Scopes) für deinen Anwendungsfall hinzu.
  scopes: [
    UserScope.Email, // Für `{POST,DELETE} /api/my-account/primary-email` APIs
    UserScope.Phone, // Für `{POST,DELETE} /api/my-account/primary-phone` APIs
    UserScope.CustomData, // Zur Verwaltung von benutzerdefinierten Daten
    UserScope.Address, // Zur Verwaltung der Adresse
    UserScope.Identities, // Für Identitäts- und MFA-bezogene APIs
    UserScope.Profile, // Zur Verwaltung des Benutzerprofils
  ],
};
```

:::

Mit der Logto Account API kannst du ein individuelles Kontoverwaltungssystem wie eine Profilseite erstellen, das vollständig in Logto integriert ist.

Einige häufige Anwendungsfälle sind:

- Benutzerprofil abrufen
- Benutzerprofil aktualisieren
- Benutzerpasswort aktualisieren
- Benutzeridentitäten wie E-Mail, Telefon und soziale Verbindungen aktualisieren
- MFA-Faktoren (Verifizierungen) verwalten

Weitere Informationen zu den verfügbaren APIs findest du in der [Logto Account API Referenz](https://openapi.logto.io/group/endpoint-my-account) und der [Logto Verification API Referenz](https://openapi.logto.io/group/endpoint-verifications).

:::note
Dedizierte Account APIs für folgende Einstellungen erscheinen in Kürze: SSO, benutzerdefinierte Daten (user) und Kontolöschung. In der Zwischenzeit kannst du diese Funktionen über die Logto Management APIs implementieren. Siehe [Kontoeinstellungen über Management API](/end-user-flows/account-settings/by-management-api) für weitere Details.

MFA-Management-APIs (TOTP und Backup-Codes) befinden sich derzeit in der Entwicklung und sind nur verfügbar, wenn das Flag `isDevFeaturesEnabled` auf `true` gesetzt ist. WebAuthn-Passkey-Management ist vollständig verfügbar.
:::

## Wie aktiviere ich die Account API \{#how-to-enable-account-api}

Standardmäßig ist die Account API deaktiviert. Um sie zu aktivieren, musst du die [Management API](/integrate-logto/interact-with-management-api) verwenden, um die globalen Einstellungen zu aktualisieren.

Der API-Endpunkt `/api/account-center` kann verwendet werden, um die Einstellungen des Account Centers abzurufen und zu aktualisieren. Du kannst damit die Account API aktivieren oder deaktivieren und die Felder anpassen.

Beispielanfrage:

```bash
curl -X PATCH https://[tenant-id].logto.app/api/account-center \
  -H 'authorization: Bearer <access_token für Logto Management API>' \
  -H 'content-type: application/json' \
  --data-raw '{"enabled":true,"fields":{"username":"Edit"}}'
```

Das Feld `enabled` dient zum Aktivieren oder Deaktivieren der Account API, und das Feld `fields` dient zur Anpassung der Felder. Der Wert kann `Off`, `Edit`, `ReadOnly` sein. Der Standardwert ist `Off`. Die Liste der Felder:

- `name`: Das Namensfeld.
- `avatar`: Das Avatar-Feld.
- `profile`: Das Profilfeld, einschließlich seiner Unterfelder.
- `username`: Das Benutzername-Feld.
- `email`: Das E-Mail-Feld.
- `phone`: Das Telefonfeld.
- `password`: Das Passwortfeld; beim Abrufen wird `true` zurückgegeben, wenn der Benutzer ein Passwort gesetzt hat, andernfalls `false`.
- `social`: Soziale Verbindungen.
- `mfa`: MFA-Faktoren.

Weitere Details zur API findest du in der [Logto Management API Referenz](https://openapi.logto.io/group/endpoint-account-center).

## Wie greife ich auf die Account API zu \{#how-to-access-account-api}

### Zugangstoken (Access token) abrufen \{#fetch-an-access-token}

Nachdem du das SDK in deiner Anwendung eingerichtet hast, kannst du die Methode `client.getAccessToken()` verwenden, um ein Zugangstoken (Access token) abzurufen. Dieses Token ist ein opakes Token (Opaque token), das für den Zugriff auf die Account API verwendet werden kann.

Wenn du das offizielle SDK nicht verwendest, solltest du das Feld `resource` für die Zugangstoken-Anfrage an `/oidc/token` leer lassen.

### Zugriff auf die Account API mit Zugangstoken (Access token) \{#access-account-api-using-access-token}

Du solltest das Zugangstoken (Access token) im `Authorization`-Feld der HTTP-Header im Bearer-Format (`Bearer YOUR_TOKEN`) beim Zugriff auf die Account API angeben.

Hier ein Beispiel, um die Benutzerkontoinformationen abzurufen:

```bash
curl https://[tenant-id].logto.app/api/my-account \
  -H 'authorization: Bearer <access_token>'
```

## Grundlegende Kontoinformationen verwalten \{#manage-basic-account-information}

### Benutzerkontoinformationen abrufen \{#retrieve-user-account-information}

Um Benutzerdaten abzurufen, kannst du den [`GET /api/my-account`](https://openapi.logto.io/operation/operation-getprofile) Endpunkt verwenden.

```bash
curl https://[tenant-id].logto.app/api/my-account \
  -H 'authorization: Bearer <access_token>'
```

Die Antwort sieht beispielsweise so aus:

```json
{
  "id": "...",
  "username": "...",
  "name": "...",
  "avatar": "..."
}
```

Die Antwortfelder können je nach Account Center-Einstellungen variieren.

### Grundlegende Kontoinformationen aktualisieren \{#update-basic-account-information}

Zu den grundlegenden Kontoinformationen gehören Benutzername, Name, Avatar, benutzerdefinierte Daten und weitere Profilinformationen.

Um **Benutzername, Name, Avatar und customData** zu aktualisieren, kannst du den [`PATCH /api/my-account`](https://openapi.logto.io/operation/operation-updateprofile) Endpunkt verwenden.

```bash
curl -X PATCH https://[tenant-id].logto.app/api/my-account \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"username":"...","name":"...","avatar":"..."}'
```

Um andere Profilinformationen zu aktualisieren, einschließlich **familyName, givenName, middleName, nickname, profile (Profilseiten-URL), website, gender, birthdate, zoneinfo, locale und address**, kannst du den [`PATCH /api/my-account/profile`](https://openapi.logto.io/operation/operation-updateotherprofile) Endpunkt verwenden.

```bash
curl -X PATCH https://[tenant-id].logto.app/api/my-account/profile \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"familyName":"...","givenName":"..."}'
```

## Identifikatoren und andere sensible Informationen verwalten \{#manage-identifiers-and-other-sensitive-information}

Aus Sicherheitsgründen erfordert die Account API eine zusätzliche Autorisierungsebene für Vorgänge, die Identifikatoren und andere sensible Informationen betreffen.

### Eine Verifizierungsdatensatz-ID erhalten \{#get-a-verification-record-id}

Zuerst musst du eine **Verifizierungsdatensatz-ID** mit einer Gültigkeit von 10 Minuten (TTL) erhalten. Diese kann verwendet werden, um die Identität des Benutzers zu überprüfen, bevor sensible Informationen aktualisiert werden. Das bedeutet, dass ein Benutzer nach erfolgreicher Verifizierung seiner Identität per Passwort, E-Mail-Verifizierungscode oder SMS-Verifizierungscode 10 Minuten Zeit hat, um seine authentifizierungsbezogenen Daten zu aktualisieren, einschließlich Identifikatoren, Zugangsdaten, Social-Account-Verknüpfung und MFA.

Um eine Verifizierungsdatensatz-ID zu erhalten, kannst du [das Passwort des Benutzers verifizieren](#verify-the-users-password) oder [einen Verifizierungscode an die E-Mail oder das Telefon des Benutzers senden](#verify-by-sending-a-verification-code-to-the-users-email-or-phone).

#### Das Passwort des Benutzers verifizieren \{#verify-the-users-password}

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/password \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"password":"..."}'
```

Die Antwort sieht beispielsweise so aus:

```json
{
  "verificationRecordId": "...",
  "expiresAt": "..."
}
```

#### Verifizierung durch Senden eines Verifizierungscodes an die E-Mail oder das Telefon des Benutzers \{#verify-by-sending-a-verification-code-to-the-users-email-or-phone}

:::note
Um diese Methode zu verwenden, musst du den [E-Mail-Connector](/connectors/email-connectors/) oder [SMS-Connector](/connectors/sms-connectors/) konfigurieren und sicherstellen, dass die `UserPermissionValidation`-Vorlage eingerichtet ist.
:::

Am Beispiel E-Mail: Fordere einen neuen Verifizierungscode an und erhalte die Verifizierungsdatensatz-ID:

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/verification-code \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"identifier":{"type":"email","value":"..."}}'
```

Die Antwort sieht beispielsweise so aus:

```json
{
  "verificationRecordId": "...",
  "expiresAt": "..."
}
```

Nach Erhalt des Verifizierungscodes kannst du ihn verwenden, um den Verifizierungsstatus des Verifizierungsdatensatzes zu aktualisieren.

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/verification-code/verify \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"identifier":{"type":"email","value":"..."},"verificationId":"...","code":"123456"}'
```

Nach erfolgreicher Verifizierung kannst du die Verifizierungsdatensatz-ID verwenden, um den Identifikator des Benutzers zu aktualisieren.

Weitere Informationen zu Verifizierungen findest du unter [Sicherheitsverifizierung über Account API](/end-user-flows/security-verification).

### Anfrage mit Verifizierungsdatensatz-ID senden \{#send-request-with-verification-record-id}

Wenn du eine Anfrage zum Aktualisieren des Identifikators des Benutzers sendest, musst du die Verifizierungsdatensatz-ID im Request-Header mit dem Feld `logto-verification-id` angeben.

### Passwort des Benutzers aktualisieren \{#update-users-password}

Um das Passwort des Benutzers zu aktualisieren, kannst du den [`POST /api/my-account/password`](https://openapi.logto.io/operation/operation-updatepassword) Endpunkt verwenden.

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/password \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"password":"..."}'
```

### Neue E-Mail aktualisieren oder verknüpfen \{#update-or-link-new-email}

:::note
Um diese Methode zu verwenden, musst du den [E-Mail-Connector](/connectors/email-connectors/) konfigurieren und sicherstellen, dass die `BindNewIdentifier`-Vorlage eingerichtet ist.
:::

Um eine neue E-Mail zu aktualisieren oder zu verknüpfen, musst du zunächst den Besitz der E-Mail nachweisen.

Rufe den [`POST /api/verifications/verification-code`](https://openapi.logto.io/operation/operation-createverificationbyverificationcode) Endpunkt auf, um einen Verifizierungscode anzufordern.

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/verification-code \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"identifier":{"type":"email","value":"..."}}'
```

In der Antwort findest du eine `verificationId` und erhältst einen Verifizierungscode per E-Mail, den du zur Verifizierung der E-Mail verwendest.

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/verification-code/verify \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"identifier":{"type":"email","value":"..."},"verificationId":"...","code":"..."}'
```

Nach erfolgreicher Verifizierung kannst du [`PATCH /api/my-account/primary-email`](https://openapi.logto.io/operation/operation-updateprimaryemail) aufrufen, um die E-Mail des Benutzers zu aktualisieren. Setze die `verificationId` im Request-Body als `newIdentifierVerificationRecordId`.

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/primary-email \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"email":"...","newIdentifierVerificationRecordId":"..."}'
```

### E-Mail des Benutzers entfernen \{#remove-the-users-email}

Um die E-Mail des Benutzers zu entfernen, kannst du den [`DELETE /api/my-account/primary-email`](https://openapi.logto.io/operation/operation-deleteprimaryemail) Endpunkt verwenden.

```bash
curl -X DELETE https://[tenant-id].logto.app/api/my-account/primary-email \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>'
```

### Telefon verwalten \{#manage-phone}

:::note
Um diese Methode zu verwenden, musst du den [SMS-Connector](/connectors/sms-connectors/) konfigurieren und sicherstellen, dass die `BindNewIdentifier`-Vorlage eingerichtet ist.
:::

Ähnlich wie beim Aktualisieren der E-Mail kannst du den [`PATCH /api/my-account/primary-phone`](https://openapi.logto.io/operation/operation-updateprimaryphone) Endpunkt verwenden, um eine neue Telefonnummer zu aktualisieren oder zu verknüpfen. Und den [`DELETE /api/my-account/primary-phone`](https://openapi.logto.io/operation/operation-deleteprimaryphone) Endpunkt, um die Telefonnummer des Benutzers zu entfernen.

### Neue soziale Verbindung verknüpfen \{#link-a-new-social-connection}

Um eine neue soziale Verbindung zu verknüpfen, musst du zunächst eine Autorisierungs-URL mit [`POST /api/verifications/social`](https://openapi.logto.io/operation/operation-createverificationbysocial) anfordern.

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/social \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"connectorId":"...","redirectUri":"...","state":"..."}'
```

- `connectorId`: Die ID des [Social Connectors](/connectors/social-connectors/).
- `redirectUri`: Die Weiterleitungs-URL nach der Autorisierung durch den Benutzer. Du solltest eine Webseite unter dieser URL hosten und den Callback abfangen.
- `state`: Der State, der nach der Autorisierung durch den Benutzer zurückgegeben wird. Es handelt sich um einen zufälligen String, der zur Verhinderung von CSRF-Angriffen dient.

In der Antwort findest du eine `verificationRecordId`, die du für spätere Schritte aufbewahren solltest.

Nachdem der Benutzer die Anwendung autorisiert hat, erhältst du einen Callback an die `redirectUri` mit dem Parameter `state`. Dann kannst du den [`POST /api/verifications/social/verify`](https://openapi.logto.io/operation/operation-verifyverificationbysocial) Endpunkt verwenden, um die soziale Verbindung zu verifizieren.

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/social/verify \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"connectorData":"...","verificationRecordId":"..."}'
```

Das `connectorData` ist die von dem Social Connector nach der Autorisierung des Benutzers zurückgegebene Daten. Du musst die Query-Parameter aus der `redirectUri` auf deiner Callback-Seite extrahieren und sie als JSON im Feld `connectorData` übergeben.

Abschließend kannst du den [`POST /api/my-account/identities`](https://openapi.logto.io/operation/operation-adduseridentities) Endpunkt verwenden, um die soziale Verbindung zu verknüpfen.

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/identities \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"newIdentifierVerificationRecordId":"..."}'
```

### Soziale Verbindung entfernen \{#remove-a-social-connection}

Um eine soziale Verbindung zu entfernen, kannst du den [`DELETE /api/my-account/identities`](https://openapi.logto.io/operation/operation-deleteidentity) Endpunkt verwenden.

```bash
curl -X DELETE https://[tenant-id].logto.app/api/my-account/identities/[connector_target_id] \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>'
```

### Neuen WebAuthn-Passkey verknüpfen \{#link-a-new-webauthn-passkey}

:::note
Denke daran, zuerst [MFA und WebAuthn zu aktivieren](/end-user-flows/mfa).
:::

:::note
Um diese Methode zu verwenden, musst du das Feld `mfa` in den [Account Center-Einstellungen](#how-to-enable-account-api) aktivieren.
:::

**Schritt 1: Ursprungs-URL deiner Frontend-App zu den zugehörigen Ursprüngen hinzufügen**

WebAuthn-Passkeys sind an einen bestimmten Hostnamen gebunden, den **Relying Party ID (RP ID)**. Nur Anwendungen, die auf dem Ursprung der RP ID gehostet werden, können Passkeys registrieren oder authentifizieren.

Da deine Frontend-Anwendung die Account API von einer anderen Domain als die Logto-Authentifizierungsseiten aufruft, musst du **Related Origins** konfigurieren, um Cross-Origin-Passkey-Operationen zu ermöglichen.

**Wie Logto die RP ID bestimmt:**

- **Standard-Setup**: Wenn du nur die Standarddomain von Logto `https://[tenant-id].logto.app` verwendest, ist die RP ID `[tenant-id].logto.app`
- **Eigene Domain**: Wenn du eine [eigene Domain](/logto-cloud/custom-domain) wie `https://auth.example.com` konfiguriert hast, ist die RP ID `auth.example.com`

**Related Origins konfigurieren:**

Verwende den [`PATCH /api/account-center`](https://openapi.logto.io/operation/operation-updateaccountcentersettings) Endpunkt, um den Ursprung deiner Frontend-Anwendung hinzuzufügen. Wenn dein Account Center beispielsweise unter `https://account.example.com` läuft:

```bash
curl -X PATCH https://[tenant-id].logto.app/api/account-center \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"webauthnRelatedOrigins":["https://account.example.com"]}'
```

Weitere Informationen zu Related Origins findest du in der [Related Origin Requests](https://passkeys.dev/docs/advanced/related-origins/) Dokumentation.

**Schritt 2: Neue Registrierungsoptionen anfordern**

Verwende den [`POST /api/verifications/web-authn/registration`](https://openapi.logto.io/operation/operation-generatewebauthnregistrationoptions) Endpunkt, um eine Registrierung für einen neuen Passkey anzufordern. Logto erlaubt es jedem Benutzerkonto, mehrere Passkeys zu registrieren.

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/web-authn/registration \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json'
```

Die Antwort sieht beispielsweise so aus:

```json
{
  "registrationOptions": "...",
  "verificationRecordId": "...",
  "expiresAt": "..."
}
```

**Schritt 3: Passkey im lokalen Browser registrieren**

Am Beispiel von [`@simplewebauthn/browser`](https://simplewebauthn.dev/) kannst du die Funktion `startRegistration` verwenden, um den Passkey im lokalen Browser zu registrieren.

```ts
import { startRegistration } from '@simplewebauthn/browser';

// ...
const response = await startRegistration({
  optionsJSON: registrationOptions, // Die vom Server in Schritt 1 zurückgegebenen Daten
});
// Speichere die Antwort für die spätere Verwendung
```

**Schritt 4: Passkey-Registrierung verifizieren**

Verwende den [`POST /api/verifications/web-authn/registration/verify`](https://openapi.logto.io/operation/operation-verifywebauthnregistration) Endpunkt, um die Passkey-Registrierung zu verifizieren.

In diesem Schritt wird die vom Authenticator generierte kryptografische Signatur überprüft, um sicherzustellen, dass der Passkey legitim erstellt wurde und während der Übertragung nicht manipuliert wurde.

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/web-authn/registration/verify \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"payload":"...","verificationRecordId":"..."}'
```

- `payload`: Die Antwort aus dem lokalen Browser in Schritt 2.
- `verificationRecordId`: Die vom Server in Schritt 1 zurückgegebene Verifizierungsdatensatz-ID.

**Schritt 5: Passkey verknüpfen**

Abschließend kannst du den Passkey mit dem Benutzerkonto verknüpfen, indem du den [`POST /api/my-account/mfa-verifications`](https://openapi.logto.io/operation/operation-addmfaverification) Endpunkt verwendest.

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/mfa-verifications \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"type":"WebAuthn","newIdentifierVerificationRecordId":"..."}'
```

- `verification_record_id`: Eine gültige Verifizierungsdatensatz-ID, die durch Verifizierung des bestehenden Faktors des Benutzers erhalten wurde. Siehe [Eine Verifizierungsdatensatz-ID erhalten](#get-a-verification-record-id) für Details.
- `type`: Der Typ des MFA-Faktors, aktuell wird nur `WebAuthn` unterstützt.
- `newIdentifierVerificationRecordId`: Die vom Server in Schritt 1 zurückgegebene Verifizierungsdatensatz-ID.

### Bestehende WebAuthn-Passkeys verwalten \{#manage-existing-webauthn-passkeys}

Um bestehende WebAuthn-Passkeys zu verwalten, kannst du den [`GET /api/my-account/mfa-verifications`](https://openapi.logto.io/operation/operation-getmfaverifications) Endpunkt verwenden, um aktuelle Passkeys und andere MFA-Verifizierungsfaktoren abzurufen.

```bash
curl https://[tenant-id].logto.app/api/my-account/mfa-verifications \
  -H 'authorization: Bearer <access_token>'
```

Die Antwort sieht beispielsweise so aus:

```json
[
  {
    "id": "...",
    "type": "WebAuthn",
    "name": "...",
    "agent": "...",
    "createdAt": "...",
    "updatedAt": "..."
  }
]
```

- `id`: Die ID der Verifizierung.
- `type`: Der Typ der Verifizierung, `WebAuthn` für WebAuthn-Passkey.
- `name`: Der Name des Passkeys, optionales Feld.
- `agent`: Der User-Agent des Passkeys.

Den Namen des Passkeys kannst du mit [`PATCH /api/my-account/mfa-verifications/{verificationId}/name`](https://openapi.logto.io/operation/operation-updatemfaverificationname) aktualisieren:

```bash
curl -X PATCH https://[tenant-id].logto.app/api/my-account/mfa-verifications/{verificationId}/name \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"name":"..."}'
```

Den Passkey kannst du mit [`DELETE /api/my-account/mfa-verifications/{verificationId}`](https://openapi.logto.io/operation/operation-deletemfaverification) löschen:

```bash
curl -X DELETE https://[tenant-id].logto.app/api/my-account/mfa-verifications/{verificationId} \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>'
```

### Neues TOTP verknüpfen \{#link-a-new-totp}

:::note
Denke daran, zuerst [MFA und TOTP zu aktivieren](/end-user-flows/mfa).
:::

:::note
Um diese Methode zu verwenden, musst du das Feld `mfa` in den [Account Center-Einstellungen](#how-to-enable-account-api) aktivieren.
:::

**Schritt 1: TOTP-Secret generieren**

Verwende den [`POST /api/my-account/mfa-verifications/totp-secret/generate`](https://openapi.logto.io/operation/operation-generatetotpsecret) Endpunkt, um ein TOTP-Secret zu generieren.

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/mfa-verifications/totp-secret/generate \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json'
```

Die Antwort sieht beispielsweise so aus:

```json
{
  "secret": "..."
}
```

**Schritt 2: TOTP-Secret dem Benutzer anzeigen**

Verwende das Secret, um einen QR-Code zu generieren oder zeige es dem Benutzer direkt an. Der Benutzer sollte es in seiner Authenticator-App (wie Google Authenticator, Microsoft Authenticator oder Authy) hinzufügen.

Das URI-Format für den QR-Code sollte sein:

```
otpauth://totp/[Issuer]:[Account]?secret=[Secret]&issuer=[Issuer]
```

Beispiel:

```
otpauth://totp/YourApp:user@example.com?secret=JBSWY3DPEHPK3PXP&issuer=YourApp
```

**Schritt 3: TOTP-Faktor binden**

Nachdem der Benutzer das Secret in seiner Authenticator-App hinzugefügt hat, muss er es verifizieren und an sein Konto binden. Verwende dazu den [`POST /api/my-account/mfa-verifications`](https://openapi.logto.io/operation/operation-addmfaverification) Endpunkt.

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/mfa-verifications \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"type":"Totp","secret":"..."}'
```

- `verification_record_id`: Eine gültige Verifizierungsdatensatz-ID, die durch Verifizierung des bestehenden Faktors des Benutzers erhalten wurde. Siehe [Eine Verifizierungsdatensatz-ID erhalten](#get-a-verification-record-id) für Details.
- `type`: Muss `Totp` sein.
- `secret`: Das in Schritt 1 generierte TOTP-Secret.

:::note
Ein Benutzer kann nur einen TOTP-Faktor gleichzeitig haben. Wenn bereits ein TOTP-Faktor existiert, führt der Versuch, einen weiteren hinzuzufügen, zu einem 422-Fehler.
:::

### Backup-Codes verwalten \{#manage-backup-codes}

:::note
Denke daran, zuerst [MFA und Backup-Codes zu aktivieren](/end-user-flows/mfa).
:::

:::note
Um diese Methode zu verwenden, musst du das Feld `mfa` in den [Account Center-Einstellungen](#how-to-enable-account-api) aktivieren.
:::

**Schritt 1: Neue Backup-Codes generieren**

Verwende den [`POST /api/my-account/mfa-verifications/backup-codes/generate`](https://openapi.logto.io/operation/operation-generatemyaccountbackupcodes) Endpunkt, um einen neuen Satz von 10 Backup-Codes zu generieren.

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/mfa-verifications/backup-codes/generate \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json'
```

Die Antwort sieht beispielsweise so aus:

```json
{
  "codes": ["...", "...", "..."]
}
```

**Schritt 2: Backup-Codes dem Benutzer anzeigen**

Bevor die Backup-Codes an das Benutzerkonto gebunden werden, musst du sie dem Benutzer anzeigen und ihn anweisen:

- Lade diese Codes sofort herunter oder schreibe sie auf
- Bewahre sie an einem sicheren Ort auf
- Jeder Code kann nur einmal verwendet werden
- Diese Codes sind die letzte Rettung, falls der Zugriff auf die primären MFA-Methoden verloren geht

Du solltest die Codes in einem klaren, einfach zu kopierenden Format anzeigen und eine Download-Option (z. B. als Textdatei oder PDF) anbieten.

**Schritt 3: Backup-Codes an das Benutzerkonto binden**

Verwende den [`POST /api/my-account/mfa-verifications`](https://openapi.logto.io/operation/operation-addmfaverification) Endpunkt, um die Backup-Codes an das Benutzerkonto zu binden.

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/mfa-verifications \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"type":"BackupCode","codes":["...","...","..."]}'
```

- `verification_record_id`: Eine gültige Verifizierungsdatensatz-ID, die durch Verifizierung des bestehenden Faktors des Benutzers erhalten wurde. Siehe [Eine Verifizierungsdatensatz-ID erhalten](#get-a-verification-record-id) für Details.
- `type`: Muss `BackupCode` sein.
- `codes`: Das Array der im vorherigen Schritt generierten Backup-Codes.

:::note

- Ein Benutzer kann immer nur einen Satz Backup-Codes gleichzeitig haben. Wenn alle Codes verwendet wurden, muss der Benutzer neue Codes generieren und binden.
- Backup-Codes können nicht der einzige MFA-Faktor sein. Der Benutzer muss mindestens einen weiteren MFA-Faktor (wie WebAuthn oder TOTP) aktiviert haben.
- Jeder Backup-Code kann nur einmal verwendet werden.

:::

**Vorhandene Backup-Codes anzeigen**

Um vorhandene Backup-Codes und deren Nutzungsstatus anzuzeigen, verwende den [`GET /api/my-account/mfa-verifications/backup-codes`](https://openapi.logto.io/operation/operation-getbackupcodes) Endpunkt:

```bash
curl https://[tenant-id].logto.app/api/my-account/mfa-verifications/backup-codes \
  -H 'authorization: Bearer <access_token>'
```

Die Antwort sieht beispielsweise so aus:

```json
{
  "codes": [
    {
      "code": "...",
      "usedAt": null
    },
    {
      "code": "...",
      "usedAt": "2024-01-15T10:30:00.000Z"
    }
  ]
}
```

- `code`: Der Backup-Code.
- `usedAt`: Der Zeitpunkt, zu dem der Code verwendet wurde, `null`, wenn noch nicht verwendet.
