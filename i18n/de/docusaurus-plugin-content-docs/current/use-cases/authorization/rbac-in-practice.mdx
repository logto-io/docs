---
sidebar_position: 1
sidebar_label: RBAC in der Praxis
description: 'Ein praktischer Leitfaden zur rollenbasierten Zugangskontrolle (RBAC): Erfahre, wie du Berechtigungen entwirfst, Rollen verwaltest und sichere Autorisierung in deinem CMS einrichtest.'
---

<head>
  <link rel="canonical" href="https://blog.logto.io/rbac-in-practice" />
</head>

# RBAC in der Praxis: Sichere Autorisierung f√ºr deine Anwendung implementieren

Hast du Schwierigkeiten, ein sicheres und skalierbares Autorisierungssystem f√ºr deine Anwendung zu implementieren? Rollenbasierte Zugangskontrolle (RBAC) ist der Industriestandard zur Verwaltung von Benutzerberechtigungen, aber die korrekte Umsetzung kann herausfordernd sein. In diesem Tutorial zeigen wir dir, wie du ein robustes RBAC-System anhand eines realen Content Management Systems (CMS) aufbaust.

Wenn du dieser Anleitung folgst, lernst du:

- ‚ú® Wie du fein abgestufte Berechtigungen entwirfst und implementierst, um pr√§zise Kontrolle zu erhalten
- üîí Best Practices zur Organisation von Berechtigungen in sinnvolle Rollen
- üë§ Techniken zur effektiven Verwaltung von Ressourcenbesitz
- üöÄ M√∂glichkeiten, dein Autorisierungssystem skalierbar und wartbar zu gestalten
- üí° Praktische Umsetzung anhand eines realen CMS-Beispiels

Der vollst√§ndige Quellcode zu diesem Tutorial ist auf [GitHub](https://github.com/logto-io/rbac-sample) verf√ºgbar.

## RBAC-Grundlagen verstehen \{#understanding-rbac-fundamentals}

Rollenbasierte Zugangskontrolle ist mehr als nur das Zuweisen von Berechtigungen an Benutzer. Es geht darum, einen strukturierten Ansatz f√ºr Autorisierung zu schaffen, der Sicherheit und Wartbarkeit in Einklang bringt.

Mehr dazu findest du unter [Was ist RBAC](https://auth-wiki.logto.io/rbac) im Auth Wiki.

Hier sind die wichtigsten Prinzipien, denen wir bei unserer Umsetzung folgen:

### Fein abgestufte Berechtigungs-Entw√ºrfe \{#fine-grained-permission-design}

Fein abgestufte Berechtigungen geben dir pr√§zise Kontrolle dar√ºber, was Benutzer in deinem System tun k√∂nnen. Anstatt grober Zugriffsebenen wie ‚ÄûAdmin‚Äú oder ‚ÄûBenutzer‚Äú definieren wir spezifische Aktionen, die Benutzer auf Ressourcen ausf√ºhren d√ºrfen. Zum Beispiel:

- `read:articles` ‚Äì Beliebigen Artikel im System ansehen
- `create:articles` ‚Äì Neue Artikel erstellen
- `update:articles` ‚Äì Bestehende Artikel bearbeiten
- `publish:articles` ‚Äì Ver√∂ffentlichungsstatus von Artikeln √§ndern

### Ressourcenbesitz und Zugangskontrolle \{#resource-ownership-and-access-control}

Ressourcenbesitz ist ein grundlegendes Konzept im Autorisierungsdesign unseres CMS. W√§hrend RBAC festlegt, welche Aktionen verschiedene Rollen ausf√ºhren d√ºrfen, f√ºgt Besitz eine pers√∂nliche Dimension zur Zugangskontrolle hinzu:

- Autoren haben automatisch Zugriff auf Artikel, die sie erstellt haben
- Dieses nat√ºrliche Besitzmodell bedeutet, dass Autoren ihre eigenen Inhalte immer ansehen und bearbeiten k√∂nnen
- Das System pr√ºft sowohl Rollenberechtigungen ODER Besitz beim Umgang mit Artikeloperationen
- Zum Beispiel kann ein Autor auch ohne die Berechtigung `update:articles` seine eigenen Artikel bearbeiten
- Dieses Design reduziert den Bedarf an zus√§tzlichen Rollenberechtigungen und erh√§lt dennoch die Sicherheit

Dieser zweistufige Ansatz (Rollen + Besitz) schafft ein intuitiveres und sichereres System. Publisher und Admins k√∂nnen weiterhin alle Inhalte √ºber ihre Rollenberechtigungen verwalten, w√§hrend Autoren die Kontrolle √ºber ihre eigenen Arbeiten behalten.

## Sichere APIs entwerfen \{#designing-a-secure-apis}

Beginnen wir damit, die Kernfunktionalit√§t unseres CMS √ºber seine API-Endpunkte zu entwerfen:

```
GET    /api/articles         # Alle Artikel auflisten
GET    /api/articles/:id     # Einen bestimmten Artikel abrufen
POST   /api/articles         # Einen neuen Artikel erstellen
PATCH  /api/articles/:id     # Einen Artikel aktualisieren
DELETE /api/articles/:id     # Einen Artikel l√∂schen
PATCH  /api/articles/:id/published  # Ver√∂ffentlichungsstatus √§ndern
```

### Zugangskontrolle f√ºr deine API implementieren \{#implement-access-control-for-your-api}

F√ºr jeden Endpunkt m√ºssen wir zwei Aspekte der Zugangskontrolle ber√ºcksichtigen:

1. Ressourcenbesitz ‚Äì Geh√∂rt dem Benutzer diese Ressource?
2. Rollenbasierte Berechtigungen ‚Äì Erlaubt die Rolle des Benutzers diese Operation?

So handhaben wir den Zugriff f√ºr jeden Endpunkt:

| Endpoint                          | Zugangskontroll-Logik                                                            |
| --------------------------------- | -------------------------------------------------------------------------------- |
| GET /api/articles                 | ‚Äì Jeder mit `list:articles`-Berechtigung ODER Autoren sehen ihre eigenen Artikel |
| GET /api/articles/:id             | ‚Äì Jeder mit `read:articles`-Berechtigung ODER Autor des Artikels                 |
| POST /api/articles                | ‚Äì Jeder mit `create:articles`-Berechtigung                                       |
| PATCH /api/articles/:id           | ‚Äì Jeder mit `update:articles`-Berechtigung ODER Autor des Artikels               |
| DELETE /api/articles/:id          | ‚Äì Jeder mit `delete:articles`-Berechtigung ODER Autor des Artikels               |
| PATCH /api/articles/:id/published | ‚Äì Nur Benutzer mit `publish:articles`-Berechtigung                               |

### Ein skalierbares Berechtigungssystem erstellen \{#creating-a-permission-system-that-scales}

Basierend auf unseren API-Zugriffsanforderungen k√∂nnen wir diese Berechtigungen definieren:

| Berechtigung     | Beschreibung                                      |
| ---------------- | ------------------------------------------------- |
| list:articles    | Die Liste aller Artikel im System ansehen         |
| read:articles    | Den vollst√§ndigen Inhalt beliebiger Artikel lesen |
| create:articles  | Neue Artikel erstellen                            |
| update:articles  | Beliebige Artikel bearbeiten                      |
| delete:articles  | Beliebige Artikel l√∂schen                         |
| publish:articles | Ver√∂ffentlichungsstatus √§ndern                    |

Beachte, dass diese Berechtigungen nur ben√∂tigt werden, wenn du auf Ressourcen zugreifst, die dir nicht geh√∂ren. Artikelbesitzer k√∂nnen automatisch:

- Ihre eigenen Artikel ansehen (kein `read:articles` n√∂tig)
- Ihre eigenen Artikel bearbeiten (kein `update:articles` n√∂tig)
- Ihre eigenen Artikel l√∂schen (kein `delete:articles` n√∂tig)

## Effektive Rollen erstellen \{#building-effective-roles}

Jetzt, da wir unsere API und Berechtigungen definiert haben, k√∂nnen wir Rollen erstellen, die diese Berechtigungen logisch gruppieren:

| Berechtigung/Rolle | üëë Admin                                    | üìù Publisher                                                  | ‚úçÔ∏è Autor                              |
| ------------------ | ------------------------------------------- | ------------------------------------------------------------- | ------------------------------------- |
| **Beschreibung**   | Vollzugriff f√ºr komplette Inhaltsverwaltung | Kann alle Artikel ansehen und Ver√∂ffentlichungsstatus steuern | Kann neue Artikel im System erstellen |
| list:articles      | ‚úÖ                                          | ‚úÖ                                                            | ‚ùå                                    |
| read:articles      | ‚úÖ                                          | ‚úÖ                                                            | ‚ùå                                    |
| create:articles    | ‚úÖ                                          | ‚ùå                                                            | ‚úÖ                                    |
| update:articles    | ‚úÖ                                          | ‚ùå                                                            | ‚ùå                                    |
| delete:articles    | ‚úÖ                                          | ‚ùå                                                            | ‚ùå                                    |
| publish:articles   | ‚úÖ                                          | ‚úÖ                                                            | ‚ùå                                    |

**Hinweis**: Autoren haben automatisch Lese-/Bearbeitungs-/L√∂schrechte f√ºr ihre eigenen Artikel, unabh√§ngig von den Rollenberechtigungen.

Jede Rolle ist mit bestimmten Verantwortlichkeiten gestaltet:

- **Admin**: Hat vollst√§ndige Kontrolle √ºber das CMS, einschlie√ülich aller Artikeloperationen
- **Publisher**: Konzentriert sich auf Inhaltspr√ºfung und Ver√∂ffentlichungsmanagement
- **Autor**: Spezialisiert auf Inhaltserstellung

Diese Rollenstruktur schafft eine klare Trennung der Verantwortlichkeiten:

- Autoren konzentrieren sich auf die Inhaltserstellung
- Publisher verwalten Inhaltsqualit√§t und Sichtbarkeit
- Admins behalten die Kontrolle √ºber das Gesamtsystem

## RBAC in Logto konfigurieren \{#config-rbac-in-logto}

Bevor du beginnst, musst du ein Konto in [Logto Cloud](https://cloud.logto.io) erstellen, oder du kannst auch eine selbst gehostete Logto-Instanz mit der [Logto OSS-Version](/logto-oss) verwenden.

F√ºr dieses Tutorial nutzen wir jedoch Logto Cloud der Einfachheit halber.

### Deine Anwendung einrichten \{#setting-up-your-application}

1. Gehe in der Logto Console zu ‚ÄûApplications‚Äú, um eine neue React-Anwendung zu erstellen
   - Anwendungsname: Content Management System
   - Anwendungstyp: Traditionelle Webanwendung
   - Redirect URIs: http://localhost:5173/callback

![CMS React application](https://uploads.strapi.logto.io/cms_application_3ed42f2256.png)

### API-Ressourcen und Berechtigungen konfigurieren \{#configuring-api-resources-and-permissions}

1. Gehe in der Logto Console zu ‚ÄûAPI Resources‚Äú, um eine neue API-Ressource zu erstellen
   - API-Name: CMS API
   - API-Identifier: https://api.cms.com
   - Berechtigungen zur API-Ressource hinzuf√ºgen
     - `list:articles`
     - `read:articles`
     - `create:articles`
     - `update:articles`
     - `publish:articles`
     - `delete:articles`

![CMS API resource details](https://uploads.strapi.logto.io/cms_api_resource_b15ae2b91a.png)

### Rollen erstellen \{#creating-roles}

Gehe zu ‚ÄûRoles‚Äú in der Logto Console, um die folgenden Rollen f√ºr das CMS zu erstellen

- Admin
  - mit allen Berechtigungen
- Publisher
  - mit `read:articles`, `list:articles`, `publish:articles`
- Autor
  - mit `create:articles`

![Admin role](https://uploads.strapi.logto.io/admin_role_53edb35ecf.png)

![Publisher role](https://uploads.strapi.logto.io/publisher_role_2ac205cc32.png)

![Author role](https://uploads.strapi.logto.io/author_role_f89cd99543.png)

### Rollen Benutzern zuweisen \{#assigning-roles-to-users}

Gehe im Bereich ‚ÄûUser management‚Äú der Logto Console zu ‚ÄûBenutzer erstellen‚Äú.

Im Tab ‚ÄûRoles‚Äú der Benutzerdetails kannst du dem Benutzer Rollen zuweisen.

In unserem Beispiel erstellen wir 3 Benutzer mit folgenden Rollen:

- Alex: Admin
- Bob: Publisher
- Charlie: Autor

![User management](https://uploads.strapi.logto.io/user_management_c0bc17119f.png)

![User details - Alex](https://uploads.strapi.logto.io/user_details_alex_702f96ef9a.png)

:::note
Zu Demonstrationszwecken erstellen wir diese Ressourcen und Konfigurationen √ºber die Logto Console. In realen Projekten kannst du diese Ressourcen und Konfigurationen programmatisch mit der von Logto bereitgestellten [Management API](/integrate-logto/interact-with-management-api) erstellen.
:::

## Dein Frontend mit Logto RBAC integrieren \{#integrate-your-frontend-with-logto-rbac}

Jetzt, da wir RBAC in Logto eingerichtet haben, k√∂nnen wir mit der Integration ins Frontend beginnen.

Folge zun√§chst den [Logto Quick Starts](/quick-starts), um Logto in deine Anwendung zu integrieren.

In unserem Beispiel verwenden wir [React](/quick-starts/react) zur Demonstration.

Nachdem du Logto in deiner Anwendung eingerichtet hast, m√ºssen wir die RBAC-Konfigurationen f√ºr Logto hinzuf√ºgen.

```tsx
// frontend/src/App.tsx

const logtoConfig: LogtoConfig = {
  appId: LOGTO_APP_ID, // Die App-ID, die du in der Logto Console erstellt hast
  endpoint: LOGTO_ENDPOINT, // Der Endpoint, den du in der Logto Console erstellt hast
  resources: [API_RESOURCE], // Der API-Ressourcen-Identifier, den du in der Logto Console erstellt hast, z. B. https://api.cms.com
  // Alle Scopes, die du von der API-Ressource im Frontend anfordern m√∂chtest
  scopes: [
    'list:articles',
    'create:articles',
    'read:articles',
    'update:articles',
    'delete:articles',
    'publish:articles',
  ],
};
```

Denke daran, dich ab- und wieder anzumelden, damit diese √Ñnderung wirksam wird, falls du bereits angemeldet bist.

Wenn sich der Benutzer mit Logto anmeldet und ein Zugangstoken f√ºr die oben angegebenen API-Ressourcen anfordert, f√ºgt Logto dem Zugangstoken Berechtigungen (Scopes) hinzu, die zur Rolle des Benutzers passen.

Du kannst `getAccessTokenClaims` aus dem `useLogto`-Hook verwenden, um die Scopes aus dem Zugangstoken zu erhalten.

```tsx
// frontend/src/hooks/use-user-data.ts

import { useLogto } from '@logto/react';
import { API_RESOURCE } from '../config';
import { useState, useEffect } from 'react';

export const useUserData = () => {
  const { getAccessTokenClaims } = useLogto();
  const [userScopes, setUserScopes] = useState<string[]>([]);
  const [userId, setUserId] = useState<string>();

  useEffect(() => {
    const fetchScopes = async () => {
      const token = await getAccessTokenClaims(API_RESOURCE);
      setUserScopes(token?.scope?.split(' ') ?? []);
      setUserId(token?.sub);
    };

    fetchScopes();
  }, [getAccessTokenClaims]);

  return { userId, userScopes };
};
```

Und du kannst `userScopes` verwenden, um zu pr√ºfen, ob der Benutzer die Berechtigung zum Zugriff auf die Ressource hat.

```tsx
// frontend/src/pages/Dashboard.tsx

const Dashboard = () => {
  const { userId, userScopes } = useUserData();
  // ...

  return (
    <div>
      {/* ... */}
      {(userScopes.includes('delete:articles') || article.ownerId === userId) && (
        <button
          onClick={() => handleDelete(article.id)}
          className="text-red-600 hover:text-red-900"
        >
          Delete
        </button>
      )}
    </div>
  );
};
```

## Dein Backend mit Logto RBAC integrieren \{#integrate-your-backend-with-logto-rbac}

Jetzt ist es an der Zeit, Logto RBAC in dein Backend zu integrieren.

### Backend-Autorisierungs-Middleware \{#backend-authorization-middleware}

Zuerst m√ºssen wir im Backend eine Middleware hinzuf√ºgen, die Benutzerberechtigungen pr√ºft, √ºberpr√ºft, ob der Benutzer angemeldet ist, und feststellt, ob er die erforderlichen Berechtigungen f√ºr bestimmte APIs hat.

```javascript
// backend/src/middleware/auth.js

const { createRemoteJWKSet, jwtVerify } = require('jose');

const getTokenFromHeader = (headers) => {
  const { authorization } = headers;
  const bearerTokenIdentifier = 'Bearer';

  if (!authorization) {
    throw new Error('Authorization header missing');
  }

  if (!authorization.startsWith(bearerTokenIdentifier)) {
    throw new Error('Authorization token type not supported');
  }

  return authorization.slice(bearerTokenIdentifier.length + 1);
};

const hasScopes = (tokenScopes, requiredScopes) => {
  if (!requiredScopes || requiredScopes.length === 0) {
    return true;
  }
  const scopeSet = new Set(tokenScopes);
  return requiredScopes.every((scope) => scopeSet.has(scope));
};

const verifyJwt = async (token) => {
  const JWKS = createRemoteJWKSet(new URL(process.env.LOGTO_JWKS_URL));

  const { payload } = await jwtVerify(token, JWKS, {
    issuer: process.env.LOGTO_ISSUER,
    audience: process.env.LOGTO_API_RESOURCE,
  });

  return payload;
};

const requireAuth = (requiredScopes = []) => {
  return async (req, res, next) => {
    try {
      // Token extrahieren
      const token = getTokenFromHeader(req.headers);

      // Token verifizieren
      const payload = await verifyJwt(token);

      // Benutzerinfo zur Anfrage hinzuf√ºgen
      req.user = {
        id: payload.sub,
        scopes: payload.scope?.split(' ') || [],
      };

      // Erforderliche Scopes pr√ºfen
      if (!hasScopes(req.user.scopes, requiredScopes)) {
        throw new Error('Insufficient permissions');
      }

      next();
    } catch (error) {
      res.status(401).json({ error: 'Unauthorized' });
    }
  };
};

module.exports = {
  requireAuth,
  hasScopes,
};
```

Wie du siehst, pr√ºfen wir in dieser Middleware, ob die Frontend-Anfrage ein g√ºltiges Zugangstoken enth√§lt und ob die Zielgruppe (Audience) des Zugangstokens mit der API-Ressource √ºbereinstimmt, die wir in der Logto Console erstellt haben.

Der Grund f√ºr die √úberpr√ºfung der API-Ressource ist, dass unsere API-Ressource tats√§chlich die Ressourcen unseres CMS-Backends repr√§sentiert und alle unsere CMS-Berechtigungen mit dieser API-Ressource verkn√ºpft sind.

Da diese API-Ressource die CMS-Ressourcen in Logto repr√§sentiert, f√ºgen wir im Frontend-Code das entsprechende Zugangstoken bei API-Anfragen an das Backend hinzu:

```typescript
// frontend/src/hooks/use-api.ts
export const useApi = () => {
  const { getAccessToken } = useLogto();

  return useMemo(
    () =>
      async (endpoint: string, options: RequestInit = {}) => {
        try {
          // Zugangstoken f√ºr die API-Ressource abrufen
          const token = await getAccessToken(API_RESOURCE);

          if (!token) {
            throw new ApiRequestError('Failed to get access token');
          }

          const response = await fetch(`${API_BASE_URL}${endpoint}`, {
            ...options,
            headers: {
              'Content-Type': 'application/json',
              // Zugangstoken zu den Request-Headern hinzuf√ºgen
              Authorization: `Bearer ${token}`,
              ...options.headers,
            },
          });

          // ... handle response

          return await response.json();
        } catch (error) {
          // ... error handling
        }
      },
    [getAccessToken]
  );
};
```

Jetzt k√∂nnen wir die `requireAuth`-Middleware verwenden, um unsere API-Endpunkte zu sch√ºtzen.

### API-Endpunkte sch√ºtzen \{#protecting-api-endpoints}

F√ºr APIs, die nur f√ºr Benutzer mit bestimmten Berechtigungen zug√§nglich sein sollen, k√∂nnen wir die Einschr√§nkungen direkt in der Middleware hinzuf√ºgen. Zum Beispiel sollte die Artikel-Erstellungs-API nur f√ºr Benutzer mit der Berechtigung `create:articles` zug√§nglich sein:

```javascript
// backend/src/routes/articles.js

const { requireAuth } = require('../middleware/auth');

router.post('/articles', requireAuth(['create:articles']), async (req, res) => {
  // ...
});
```

F√ºr APIs, die sowohl Berechtigungen als auch Ressourcenbesitz pr√ºfen m√ºssen, k√∂nnen wir die Funktion `hasScopes` verwenden. Zum Beispiel k√∂nnen Benutzer mit dem Scope `list:articles` alle Artikel abrufen, w√§hrend Autoren nur ihre eigenen erstellten Artikel sehen:

```javascript
// backend/src/routes/articles.js

const { requireAuth, hasScopes } = require('../middleware/auth');

router.get('/articles', requireAuth(), async (req, res) => {
  try {
    // Wenn der Benutzer den Scope list:articles hat, alle Artikel zur√ºckgeben
    if (hasScopes(req.user.scopes, ['list:articles'])) {
      const articles = await articleDB.list();
      return res.json(articles);
    }

    // Andernfalls nur die eigenen Artikel des Benutzers zur√ºckgeben
    const articles = await articleDB.listByOwner(req.user.id);
    res.json(articles);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch articles' });
  }
});
```

An diesem Punkt haben wir die RBAC-Implementierung abgeschlossen. Du kannst dir [den vollst√§ndigen Quellcode](https://github.com/logto-io/rbac-sample) ansehen, um die komplette Umsetzung zu sehen.

## Die CMS RBAC-Implementierung testen \{#test-the-cms-rbac-implementation}

Jetzt testen wir unsere CMS RBAC-Implementierung mit den drei gerade erstellten Benutzern.

:::note
Falls du dich mit den Zugangsdaten der in ‚ÄûUser Management‚Äú erstellten Benutzer nicht anmelden kannst, musst du zuerst die entsprechende Anmeldemethode aktivieren. Gehe in der Logto Console zu ‚ÄûSign-in Experience‚Äú und aktiviere deine bevorzugte Authentifizierungsmethode (z. B. E-Mail + Passwort oder Benutzername + Passwort).
:::

Melden wir uns zun√§chst als Alex und Charles an und erstellen einige Artikel.

Da Alex die Admin-Rolle hat, kann er Artikel erstellen, l√∂schen, aktualisieren, ver√∂ffentlichen und alle Artikel ansehen.

![CMS dashboard - Alex](https://uploads.strapi.logto.io/cms_dashboard_alex_a11863a94b.png)

Charles, mit der Autor-Rolle, kann nur eigene Artikel erstellen und nur Artikel sehen, bearbeiten und l√∂schen, die ihm geh√∂ren.

![CMS dashboard - Charles - Article list](https://uploads.strapi.logto.io/cms_dashboard_charles_05f610066a.png)

Bob, mit der Publisher-Rolle, kann alle Artikel ansehen und ver√∂ffentlichen, aber keine erstellen, bearbeiten oder l√∂schen.

![CMS dashboard - Bob](https://uploads.strapi.logto.io/cms_dashboard_bob_421a429b69.png)

## Fazit \{#conclusion}

Herzlichen Gl√ºckwunsch! Du hast gelernt, wie du ein robustes RBAC-System in deiner Anwendung implementierst.

F√ºr komplexere Szenarien, wie den Aufbau von Multi-Tenant-Anwendungen, bietet Logto umfassende Organisationsunterst√ºtzung. Sieh dir unseren Leitfaden [Eine Multi-Tenant SaaS-Anwendung bauen: Ein vollst√§ndiger Leitfaden von Design bis Implementierung](https://blog.logto.io/build-multi-tenant-saas-application) an, um mehr √ºber die Umsetzung von organisationsweiter Zugangskontrolle zu erfahren.

Viel Spa√ü beim Coden! üöÄ
