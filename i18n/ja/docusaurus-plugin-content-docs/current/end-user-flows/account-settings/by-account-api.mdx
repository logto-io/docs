---
description: Account API を使用してユーザーを管理する方法を学ぶ
sidebar_position: 1
---

# Account API によるアカウント設定

## Logto Account API とは \{#what-is-logto-account-api}

Logto Account API は、エンドユーザーが Management API を経由せずに直接 API アクセスできる包括的な API 群です。主な特徴は以下の通りです：

- 直接アクセス：Account API により、エンドユーザーは Management API の中継なしで自身のアカウントプロファイルへ直接アクセス・管理できます。
- ユーザープロファイルとアイデンティティ管理：ユーザーは自身のプロファイルやセキュリティ設定を完全に管理でき、メール・電話・パスワードなどのアイデンティティ情報の更新やソーシャル連携の管理が可能です。多要素認証 (MFA) やシングルサインオン (SSO) のサポートも近日公開予定です。
- グローバルアクセス制御：管理者はアクセス設定をグローバルに完全管理でき、各フィールドごとにカスタマイズ可能です。
- シームレスな認可 (Authorization)：認可 (Authorization) がこれまで以上に簡単に！`client.getAccessToken()` を使って OP (Logto) 用の不透明トークン (Opaque token) を取得し、`Authorization` ヘッダーに `Bearer <access_token>` として付与するだけです。

Logto Account API を使えば、Logto と完全連携したプロフィールページのようなカスタムアカウント管理システムを構築できます。

よくあるユースケースは以下の通りです：

- ユーザープロファイルの取得
- ユーザープロファイルの更新
- ユーザーパスワードの更新
- メール・電話・ソーシャル連携などのユーザーアイデンティティの更新
- MFA 要素（認証要素）の管理

利用可能な API について詳しくは [Logto Account API リファレンス](https://openapi.logto.io/group/endpoint-my-account) および [Logto Verification API リファレンス](https://openapi.logto.io/group/endpoint-verifications) をご覧ください。

:::note

SSO アカウントの閲覧やアカウント削除機能は現在 Logto Management API で提供されています。実装の詳細は [Management API によるアカウント設定](/end-user-flows/account-settings/by-management-api) をご参照ください。

:::

## Account API の有効化方法 \{#how-to-enable-account-api}

<CloudLink to="/sign-in-experience/account-center">
  コンソール > サインイン & アカウント > アカウントセンター
</CloudLink>
に移動します。

Account API はデフォルトで無効化されており、アクセス制御もロックされています。**Account API を有効化** を切り替えてオンにします。

有効化後は、識別子・プロファイルデータ・サードパーティトークンアクセスごとにフィールド単位で権限を設定できます。各フィールドは `Off`、`ReadOnly`、`Edit` をサポートし、デフォルトは `Off` です。

1. **セキュリティフィールド**:
   - 対象フィールド：プライマリメール、プライマリ電話、ソーシャルアイデンティティ、パスワード、MFA。
   - エンドユーザーがこれらのフィールドを編集する前に、パスワード・メール・SMS で本人確認を行い、10 分間有効な認証記録 ID を取得する必要があります。詳細は [認証記録 ID の取得](#get-a-verification-record-id) を参照してください。
   - MFA 用に WebAuthn パスキーを利用する場合は、フロントエンドアプリのドメインを **WebAuthn 関連オリジン** に追加し、アカウントセンターとサインイン体験でパスキーを共有できるようにします。詳細は [新しい WebAuthn パスキーの連携](#link-a-new-webauthn-passkey) を参照してください。
2. **プロファイルフィールド**:
   - 対象フィールド：ユーザー名、名前、アバター、[プロファイル](/user-management/user-data#profile)（その他標準プロファイル属性）、[カスタムデータ](/user-management/user-data#custom-data)。
   - これらは追加認証なしでエンドユーザーが編集可能です。
3. **シークレットボールト**：OIDC や OAuth のソーシャル・エンタープライズコネクター用に、Logto の [シークレットボールト](/secret-vault/federated-token-set) が認証後のサードパーティアクセストークン・リフレッシュトークンを安全に保存します。これにより、アプリはユーザーに再度サインインを求めることなく外部 API（例：Google カレンダーイベントの同期など）を呼び出せます。Account API を有効化すると自動的にトークン取得が可能になります。

## Account API へのアクセス方法 \{#how-to-access-account-api}

:::note
アクセストークンに適切な権限が付与されていることを確認するため、Logto 設定で対応するスコープを正しく設定してください。

例えば、`POST /api/my-account/primary-email` API には `email` スコープ、`POST /api/my-account/primary-phone` API には `phone` スコープが必要です。

```ts
import { type LogtoConfig, UserScope } from '@logto/js';

const config: LogtoConfig = {
  // ...他のオプション
  // ユースケースに合った適切なスコープを追加
  scopes: [
    UserScope.Email, // `{POST,DELETE} /api/my-account/primary-email` 用
    UserScope.Phone, // `{POST,DELETE} /api/my-account/primary-phone` 用
    UserScope.CustomData, // カスタムデータ管理用
    UserScope.Address, // 住所管理用
    UserScope.Identities, // アイデンティティ・MFA 関連 API 用
    UserScope.Profile, // ユーザープロファイル管理用
  ],
};
```

:::

### アクセストークンの取得 \{#fetch-an-access-token}

アプリケーションで SDK をセットアップした後、`client.getAccessToken()` メソッドでアクセストークンを取得できます。このトークンは Account API へのアクセスに利用できる不透明トークン (Opaque token) です。

公式 SDK を利用しない場合は、アクセストークングラントリクエスト `/oidc/token` の `resource` を空に設定してください。

### アクセストークンを使った Account API へのアクセス \{#access-account-api-using-access-token}

Account API へリクエストする際は、HTTP ヘッダーの `Authorization` フィールドに Bearer 形式（`Bearer YOUR_TOKEN`）でアクセストークンを含めてください。

ユーザーアカウント情報を取得する例：

```bash
curl https://[tenant-id].logto.app/api/my-account \
  -H 'authorization: Bearer <access_token>'
```

## 基本的なアカウント情報の管理 \{#manage-basic-account-information}

### ユーザーアカウント情報の取得 \{#retrieve-user-account-information}

ユーザーデータを取得するには、[`GET /api/my-account`](https://openapi.logto.io/operation/operation-getprofile) エンドポイントを利用します。

```bash
curl https://[tenant-id].logto.app/api/my-account \
  -H 'authorization: Bearer <access_token>'
```

レスポンス例：

```json
{
  "id": "...",
  "username": "...",
  "name": "...",
  "avatar": "..."
}
```

レスポンスフィールドはアカウントセンターの設定によって異なる場合があります。

### 基本的なアカウント情報の更新 \{#update-basic-account-information}

基本的なアカウント情報には、ユーザー名・名前・アバター・カスタムデータ・その他プロファイル情報が含まれます。

**ユーザー名・名前・アバター・customData** を更新するには、[`PATCH /api/my-account`](https://openapi.logto.io/operation/operation-updateprofile) エンドポイントを利用します。

```bash
curl -X PATCH https://[tenant-id].logto.app/api/my-account \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"username":"...","name":"...","avatar":"..."}'
```

**familyName, givenName, middleName, nickname, profile (プロフィールページ URL), website, gender, birthdate, zoneinfo, locale, address** など他のプロファイル情報を更新するには、[`PATCH /api/my-account/profile`](https://openapi.logto.io/operation/operation-updateotherprofile) エンドポイントを利用します。

```bash
curl -X PATCH https://[tenant-id].logto.app/api/my-account/profile \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"familyName":"...","givenName":"..."}'
```

## 識別子やその他の機微情報の管理 \{#manage-identifiers-and-other-sensitive-information}

セキュリティ上の理由から、Account API では識別子やその他の機微情報を扱う操作に追加の認可 (Authorization) 層が必要です。

### 認証記録 ID の取得 \{#get-a-verification-record-id}

まず、10 分間有効な **認証記録 ID** を取得する必要があります。これは機微情報の更新前にユーザーの本人確認を行うために使用します。つまり、ユーザーがパスワード・メール認証コード・SMS 認証コードで本人確認に成功すると、10 分間は識別子・認証情報・ソーシャル連携・MFA など認証関連データを更新できます。

認証記録 ID を取得するには、[ユーザーパスワードで認証](#verify-the-users-password) または [メールや電話に認証コードを送信して認証](#verify-by-sending-a-verification-code-to-the-users-email-or-phone) を利用します。

#### ユーザーパスワードで認証 \{#verify-the-users-password}

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/password \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"password":"..."}'
```

レスポンス例：

```json
{
  "verificationRecordId": "...",
  "expiresAt": "..."
}
```

#### メールや電話に認証コードを送信して認証 \{#verify-by-sending-a-verification-code-to-the-users-email-or-phone}

:::note
この方法を利用するには、[メールコネクター](/connectors/email-connectors/) または [SMS コネクター](/connectors/sms-connectors/) を設定し、`UserPermissionValidation` テンプレートが設定されていることを確認してください。
:::

メールを例に、新しい認証コードをリクエストし認証記録 ID を取得します：

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/verification-code \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"identifier":{"type":"email","value":"..."}}'
```

レスポンス例：

```json
{
  "verificationRecordId": "...",
  "expiresAt": "..."
}
```

認証コードを受け取ったら、それを使って認証記録の認証ステータスを更新できます。

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/verification-code/verify \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"identifier":{"type":"email","value":"..."},"verificationId":"...","code":"123456"}'
```

コード認証後、認証記録 ID を使ってユーザーの識別子を更新できます。

認証について詳しくは [Account API によるセキュリティ認証](/end-user-flows/security-verification) をご参照ください。

### 認証記録 ID を付与してリクエスト送信 \{#send-request-with-verification-record-id}

ユーザー識別子を更新するリクエストを送信する際は、リクエストヘッダーの `logto-verification-id` フィールドに認証記録 ID を含めてください。

### ユーザーパスワードの更新 \{#update-users-password}

ユーザーパスワードを更新するには、[`POST /api/my-account/password`](https://openapi.logto.io/operation/operation-updatepassword) エンドポイントを利用します。

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/password \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"password":"..."}'
```

:::tip
サインアップ時と同様、Account API で設定するパスワードも <CloudLink to="/security/password-policy">コンソール > セキュリティ > パスワードポリシー</CloudLink> で設定した [パスワードポリシー](/security/password-policy) に準拠する必要があります。ポリシー違反時は Logto が詳細なバリデーション結果とエラーメッセージを返します。
:::

### 新しいメールの更新・連携 \{#update-or-link-new-email}

:::note
この方法を利用するには、[メールコネクター](/connectors/email-connectors/) を設定し、`BindNewIdentifier` テンプレートが設定されていることを確認してください。
:::

新しいメールを更新・連携するには、まずそのメールの所有権を証明する必要があります。

[`POST /api/verifications/verification-code`](https://openapi.logto.io/operation/operation-createverificationbyverificationcode) エンドポイントで認証コードをリクエストします。

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/verification-code \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"identifier":{"type":"email","value":"..."}}'
```

レスポンスで `verificationId` が返され、メールで認証コードを受け取ります。それを使ってメールを認証します。

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/verification-code/verify \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"identifier":{"type":"email","value":"..."},"verificationId":"...","code":"..."}'
```

コード認証後、[`PATCH /api/my-account/primary-email`](https://openapi.logto.io/operation/operation-updateprimaryemail) を呼び出してユーザーのメールを更新し、`verificationId` をリクエストボディの `newIdentifierVerificationRecordId` に設定します。

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/primary-email \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"email":"...","newIdentifierVerificationRecordId":"..."}'
```

:::tip
サインアップ時と同様、Account API で連携されるメールも <CloudLink to="/security/blocklist">コンソール > セキュリティ > ブロックリスト</CloudLink> で設定した [ブロックリスト](/security/blocklist) 検証に合格する必要があります。ポリシー違反時は Logto がリクエストを拒否し、詳細なエラーを返します。
:::

### ユーザーのメール削除 \{#remove-the-users-email}

ユーザーのメールを削除するには、[`DELETE /api/my-account/primary-email`](https://openapi.logto.io/operation/operation-deleteprimaryemail) エンドポイントを利用します。

```bash
curl -X DELETE https://[tenant-id].logto.app/api/my-account/primary-email \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>'
```

### 電話番号の管理 \{#manage-phone}

:::note
この方法を利用するには、[SMS コネクター](/connectors/sms-connectors/) を設定し、`BindNewIdentifier` テンプレートが設定されていることを確認してください。
:::

メール更新と同様に、[`PATCH /api/my-account/primary-phone`](https://openapi.logto.io/operation/operation-updateprimaryphone) エンドポイントで新しい電話番号の更新・連携、[`DELETE /api/my-account/primary-phone`](https://openapi.logto.io/operation/operation-deleteprimaryphone) エンドポイントでユーザーの電話番号削除が可能です。

### 新しいソーシャル連携の追加 \{#link-a-new-social-connection}

新しいソーシャル連携を追加するには、まず [`POST /api/verifications/social`](https://openapi.logto.io/operation/operation-createverificationbysocial) で認可 URL をリクエストします。

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/social \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"connectorId":"...","redirectUri":"...","state":"..."}'
```

- `connectorId`: [ソーシャルコネクター](/connectors/social-connectors/) の ID
- `redirectUri`: ユーザーがアプリを認可した後のリダイレクト先 URL。この URL でコールバックを受け取る必要があります。
- `state`: 認可後に返されるランダムな文字列で、CSRF 攻撃防止用です。

レスポンスで `verificationRecordId` が返されるので、後で利用できるよう保持します。

ユーザーがアプリを認可すると、`redirectUri` で `state` パラメータ付きのコールバックを受け取ります。その後、[`POST /api/verifications/social/verify`](https://openapi.logto.io/operation/operation-verifyverificationbysocial) エンドポイントでソーシャル連携を認証します。

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/social/verify \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"connectorData":"...","verificationRecordId":"..."}'
```

`connectorData` は、ユーザーがアプリを認可した後にソーシャルコネクターから返されるデータです。コールバックページで `redirectUri` のクエリパラメータをパースし、`connectorData` フィールドの値として JSON でラップしてください。

最後に、[`POST /api/my-account/identities`](https://openapi.logto.io/operation/operation-adduseridentities) エンドポイントでソーシャル連携を追加します。

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/identities \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"newIdentifierVerificationRecordId":"..."}'
```

### ソーシャル連携の削除 \{#remove-a-social-connection}

ソーシャル連携を削除するには、[`DELETE /api/my-account/identities`](https://openapi.logto.io/operation/operation-deleteidentity) エンドポイントを利用します。

```bash
curl -X DELETE https://[tenant-id].logto.app/api/my-account/identities/[connector_target_id] \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>'
```

### 新しい WebAuthn パスキーの連携 \{#link-a-new-webauthn-passkey}

:::note
まず [MFA と WebAuthn の有効化](/end-user-flows/mfa) を忘れずに行ってください。
:::

:::note
この方法を利用するには、[アカウントセンター設定](#how-to-enable-account-api) で `mfa` フィールドを有効化する必要があります。
:::

**ステップ 1: フロントエンドアプリのオリジンを関連オリジンに追加**

WebAuthn パスキーは **Relying Party ID (RP ID)** と呼ばれる特定のホスト名に紐づきます。RP ID のオリジンでホストされているアプリケーションのみが、そのパスキーで登録・認証できます。

フロントエンドアプリが Logto の認証ページとは異なるドメインから Account API を呼び出す場合、クロスオリジンでパスキー操作を許可するため **関連オリジン** の設定が必要です。

**Logto が RP ID を決定する方法：**

- **デフォルト設定**：Logto のデフォルトドメイン `https://[tenant-id].logto.app` のみを利用する場合、RP ID は `[tenant-id].logto.app`
- **カスタムドメイン**： [カスタムドメイン](/logto-cloud/custom-domain) 例：`https://auth.example.com` を設定した場合、RP ID は `auth.example.com`

**関連オリジンの設定方法：**

[`PATCH /api/account-center`](https://openapi.logto.io/operation/operation-updateaccountcentersettings) エンドポイントでフロントエンドアプリのオリジンを追加します。例：アカウントセンターが `https://account.example.com` で動作している場合：

```bash
curl -X PATCH https://[tenant-id].logto.app/api/account-center \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"webauthnRelatedOrigins":["https://account.example.com"]}'
```

:::note

WebAuthn では関連オリジンとして最大 5 つのユニークな eTLD+1 ラベルをサポートします。eTLD+1（有効なトップレベルドメイン＋1 ラベル）は登録可能なドメイン部分です。例：

- `https://example.com`、`https://app.example.com`、`https://auth.example.com` は **1** ラベル（`example.com`）としてカウント
- `https://shopping.com`、`https://shopping.co.uk`、`https://shopping.co.jp` も **1** ラベル（`shopping`）としてカウント
- `https://example.com` と `https://another.com` は **2** ラベル

5 ドメインを超える関連オリジンが必要な場合は、[Related Origin Requests](https://passkeys.dev/docs/advanced/related-origins/) ドキュメントを参照してください。

:::

**ステップ 2: 新規登録オプションのリクエスト**

[`POST /api/verifications/web-authn/registration`](https://openapi.logto.io/operation/operation-generatewebauthnregistrationoptions) エンドポイントで新しいパスキー登録をリクエストします。Logto では 1 アカウントにつき複数のパスキー登録が可能です。

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/web-authn/registration \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json'
```

レスポンス例：

```json
{
  "registrationOptions": "...",
  "verificationRecordId": "...",
  "expiresAt": "..."
}
```

**ステップ 3: ローカルブラウザでパスキー登録**

[`@simplewebauthn/browser`](https://simplewebauthn.dev/) を例に、`startRegistration` 関数でローカルブラウザにパスキーを登録します。

```ts
import { startRegistration } from '@simplewebauthn/browser';

// ...
const response = await startRegistration({
  optionsJSON: registrationOptions, // ステップ 1 でサーバーから返されたデータ
});
// レスポンスを後で利用できるよう保存
```

**ステップ 4: パスキー登録の認証**

[`POST /api/verifications/web-authn/registration/verify`](https://openapi.logto.io/operation/operation-verifywebauthnregistration) エンドポイントでパスキー登録を認証します。

このステップでは、認証器が生成した暗号署名を検証し、パスキーが正当に作成され送信中に改ざんされていないことを確認します。

```bash
curl -X POST https://[tenant-id].logto.app/api/verifications/web-authn/registration/verify \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json' \
  --data-raw '{"payload":"...","verificationRecordId":"..."}'
```

- `payload`: ステップ 2 のローカルブラウザからのレスポンス
- `verificationRecordId`: ステップ 1 でサーバーから返された認証記録 ID

**ステップ 5: パスキーの連携**

最後に、[`POST /api/my-account/mfa-verifications`](https://openapi.logto.io/operation/operation-addmfaverification) エンドポイントでパスキーをユーザーアカウントに連携します。

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/mfa-verifications \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"type":"WebAuthn","newIdentifierVerificationRecordId":"..."}'
```

- `verification_record_id`: 既存要素の認証で付与された有効な認証記録 ID。詳細は [認証記録 ID の取得](#get-a-verification-record-id) を参照。
- `type`: MFA 要素のタイプ。現在は `WebAuthn` のみサポート。
- `newIdentifierVerificationRecordId`: ステップ 1 でサーバーから返された認証記録 ID

### 既存 WebAuthn パスキーの管理 \{#manage-existing-webauthn-passkeys}

既存の WebAuthn パスキー管理には、[`GET /api/my-account/mfa-verifications`](https://openapi.logto.io/operation/operation-getmfaverifications) エンドポイントで現在のパスキーや他の MFA 認証要素を取得します。

```bash
curl https://[tenant-id].logto.app/api/my-account/mfa-verifications \
  -H 'authorization: Bearer <access_token>'
```

レスポンス例：

```json
[
  {
    "id": "...",
    "type": "WebAuthn",
    "name": "...",
    "agent": "...",
    "createdAt": "...",
    "updatedAt": "..."
  }
]
```

- `id`: 認証要素の ID
- `type`: 認証要素のタイプ。WebAuthn パスキーの場合は `WebAuthn`
- `name`: パスキー名（任意）
- `agent`: パスキーのユーザーエージェント

パスキー名の更新は [`PATCH /api/my-account/mfa-verifications/{verificationId}/name`](https://openapi.logto.io/operation/operation-updatemfaverificationname) エンドポイントで行います：

```bash
curl -X PATCH https://[tenant-id].logto.app/api/my-account/mfa-verifications/{verificationId}/name \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"name":"..."}'
```

パスキー削除は [`DELETE /api/my-account/mfa-verifications/{verificationId}`](https://openapi.logto.io/operation/operation-deletemfaverification) エンドポイントで行います：

```bash
curl -X DELETE https://[tenant-id].logto.app/api/my-account/mfa-verifications/{verificationId} \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>'
```

### 新しい TOTP の連携 \{#link-a-new-totp}

:::note
まず [MFA と TOTP の有効化](/end-user-flows/mfa) を忘れずに行ってください。
:::

:::note
この方法を利用するには、[アカウントセンター設定](#how-to-enable-account-api) で `mfa` フィールドを有効化する必要があります。
:::

**ステップ 1: TOTP シークレットの生成**

[`POST /api/my-account/mfa-verifications/totp-secret/generate`](https://openapi.logto.io/operation/operation-generatetotpsecret) エンドポイントで TOTP シークレットを生成します。

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/mfa-verifications/totp-secret/generate \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json'
```

レスポンス例：

```json
{
  "secret": "..."
}
```

**ステップ 2: ユーザーに TOTP シークレットを表示**

シークレットを使って QR コードを生成するか、直接ユーザーに表示します。ユーザーはこれを Google Authenticator、Microsoft Authenticator、Authy などの認証アプリに追加します。

QR コードの URI 形式は：

```
otpauth://totp/[Issuer]:[Account]?secret=[Secret]&issuer=[Issuer]
```

例：

```
otpauth://totp/YourApp:user@example.com?secret=JBSWY3DPEHPK3PXP&issuer=YourApp
```

**ステップ 3: TOTP 要素の連携**

ユーザーが認証アプリにシークレットを追加した後、それを認証してアカウントに連携します。[`POST /api/my-account/mfa-verifications`](https://openapi.logto.io/operation/operation-addmfaverification) エンドポイントを利用します。

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/mfa-verifications \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"type":"Totp","secret":"..."}'
```

- `verification_record_id`: 既存要素の認証で付与された有効な認証記録 ID。詳細は [認証記録 ID の取得](#get-a-verification-record-id) を参照。
- `type`: `Totp` を指定
- `secret`: ステップ 1 で生成した TOTP シークレット

:::note
ユーザーは TOTP 要素を 1 つだけ持つことができます。すでに TOTP 要素がある場合、追加しようとすると 422 エラーになります。
:::

### バックアップコードの管理 \{#manage-backup-codes}

:::note
まず [MFA とバックアップコードの有効化](/end-user-flows/mfa) を忘れずに行ってください。
:::

:::note
この方法を利用するには、[アカウントセンター設定](#how-to-enable-account-api) で `mfa` フィールドを有効化する必要があります。
:::

**ステップ 1: 新しいバックアップコードの生成**

[`POST /api/my-account/mfa-verifications/backup-codes/generate`](https://openapi.logto.io/operation/operation-generatemyaccountbackupcodes) エンドポイントで新しい 10 個のバックアップコードを生成します。

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/mfa-verifications/backup-codes/generate \
  -H 'authorization: Bearer <access_token>' \
  -H 'content-type: application/json'
```

レスポンス例：

```json
{
  "codes": ["...", "...", "..."]
}
```

**ステップ 2: バックアップコードをユーザーに表示**

バックアップコードをユーザーアカウントに連携する前に、必ずユーザーに表示し、以下を案内してください：

- すぐにダウンロードまたは書き留めること
- 安全な場所に保管すること
- 各コードは 1 回しか使えないこと
- これらのコードは主要な MFA 手段を失った場合の最後の手段であること

コピーしやすい形式で表示し、ダウンロード（テキストファイルや PDF など）も検討してください。

**ステップ 3: バックアップコードの連携**

[`POST /api/my-account/mfa-verifications`](https://openapi.logto.io/operation/operation-addmfaverification) エンドポイントでバックアップコードをユーザーアカウントに連携します。

```bash
curl -X POST https://[tenant-id].logto.app/api/my-account/mfa-verifications \
  -H 'authorization: Bearer <access_token>' \
  -H 'logto-verification-id: <verification_record_id>' \
  -H 'content-type: application/json' \
  --data-raw '{"type":"BackupCode","codes":["...","...","..."]}'
```

- `verification_record_id`: 既存要素の認証で付与された有効な認証記録 ID。詳細は [認証記録 ID の取得](#get-a-verification-record-id) を参照。
- `type`: `BackupCode` を指定
- `codes`: 前ステップで生成したバックアップコード配列

:::note

- ユーザーは 1 セットのバックアップコードしか持てません。すべてのコードを使い切った場合は新たに生成・連携が必要です。
- バックアップコードだけを MFA 要素とすることはできません。必ず他の MFA 要素（WebAuthn や TOTP など）が有効である必要があります。
- 各バックアップコードは 1 回のみ利用可能です。

:::

**既存バックアップコードの確認**

既存のバックアップコードと使用状況を確認するには、[`GET /api/my-account/mfa-verifications/backup-codes`](https://openapi.logto.io/operation/operation-getbackupcodes) エンドポイントを利用します：

```bash
curl https://[tenant-id].logto.app/api/my-account/mfa-verifications/backup-codes \
  -H 'authorization: Bearer <access_token>'
```

レスポンス例：

```json
{
  "codes": [
    {
      "code": "...",
      "usedAt": null
    },
    {
      "code": "...",
      "usedAt": "2024-01-15T10:30:00.000Z"
    }
  ]
}
```

- `code`: バックアップコード
- `usedAt`: コードが使用された日時。未使用の場合は `null`
