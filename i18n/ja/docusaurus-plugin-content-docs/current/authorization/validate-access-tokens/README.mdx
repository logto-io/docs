---
sidebar_position: 6
sidebar_label: API でアクセス トークンを検証する
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

import DotNetAddValidationLogic from './dotnet/_add-validation-logic.mdx';
import DotNetApplyMiddleware from './dotnet/_apply-middleware.mdx';
import DotNetInit from './dotnet/_init.mdx';
import GoAddValidationLogic from './go/_add-validation-logic.mdx';
import GoApplyMiddleware from './go/_apply-middleware.mdx';
import GoInit from './go/_init.mdx';
import JavaAddValidationLogic from './java/_add-validation-logic.mdx';
import JavaApplyMiddleware from './java/_apply-middleware.mdx';
import JavaInit from './java/_init.mdx';
import NodeAddValidationLogic from './nodejs/_add-validation-logic.mdx';
import NodeApplyMiddleware from './nodejs/_apply-middleware.mdx';
import NodeInit from './nodejs/_init.mdx';
import PhpAddValidationLogic from './php/_add-validation-logic.mdx';
import PhpApplyMiddleware from './php/_apply-middleware.mdx';
import PhpInit from './php/_init.mdx';
import PythonAddValidationLogic from './python/_add-validation-logic.mdx';
import PythonApplyMiddleware from './python/_apply-middleware.mdx';
import PythonInit from './python/_init.mdx';
import RubyAddValidationLogic from './ruby/_add-validation-logic.mdx';
import RubyApplyMiddleware from './ruby/_apply-middleware.mdx';
import RubyInit from './ruby/_init.mdx';
import RustAddValidationLogic from './rust/_add-validation-logic.mdx';
import RustApplyMiddleware from './rust/_apply-middleware.mdx';
import RustInit from './rust/_init.mdx';

# API サービスやバックエンドでアクセス トークンを検証する方法

アクセス トークンの検証は、Logto で [ロールベースのアクセス制御 (RBAC)](/authorization/role-based-access-control) を強制するための重要な部分です。このガイドでは、バックエンド / API で Logto が発行した JWT を検証し、署名、発行者 (Issuer)、オーディエンス (Audience)、有効期限、権限 (スコープ)、組織コンテキストをチェックする方法を説明します。

## 始める前に \{#before-you-start}

- このガイドは、Logto の RBAC 概念に精通していることを前提としています。
- API リソースを保護する場合、このガイドは [グローバル API リソースの保護](/authorization/global-api-resources) ガイドを完了していることを前提としています。
- アプリ内機能やワークフロー（非 API 権限）を保護する場合、このガイドは [組織（非 API）権限の保護](/authorization/organization-permissions) ガイドを完了していることを前提としています。
- 組織レベルの API リソースを保護する場合、このガイドは [組織レベルの API リソースの保護](/authorization/organization-level-api-resources) ガイドを完了していることを前提としています。

## ステップ 1: 定数とユーティリティの初期化 \{#step-1-initialize-constants-and-utilities}

トークンの抽出と検証を処理するために、必要な定数とユーティリティをコード内で定義します。有効なリクエストには、`Authorization` ヘッダーが `Bearer <access_token>` の形式で含まれている必要があります。

<Tabs groupId="api-language">
  <TabItem value="node" label="Node.js">
    <NodeInit />
  </TabItem>
  <TabItem value="python" label="Python">
    <PythonInit />
  </TabItem>
  <TabItem value="go" label="Go">
    <GoInit />
  </TabItem>
  <TabItem value="java" label="Java">
    <JavaInit />
  </TabItem>
  <TabItem value="dotnet" label=".NET">
    <DotNetInit />
  </TabItem>
  <TabItem value="php" label="PHP">
    <PhpInit />
  </TabItem>
  <TabItem value="ruby" label="Ruby">
    <RubyInit />
  </TabItem>
  <TabItem value="rust" label="Rust">
    <RustInit />
  </TabItem>
</Tabs>

## ステップ 2: Logto テナント情報の取得 \{#step-2-retrieve-info-about-your-logto-tenant}

Logto が発行したトークンを検証するには、以下の値が必要です：

- JSON Web Key Set (JWKS) URI：JWT の署名を検証するために使用する Logto の公開鍵の URL。
- 発行者 (Issuer)：期待される発行者値（Logto の OIDC URL）。

まず、Logto テナントのエンドポイントを探します。以下の場所で確認できます：

- Logto コンソールの **設定** → **ドメイン**。
- Logto で設定した任意のアプリケーション設定内の **設定** → **エンドポイント & 資格情報**。

### OpenID Connect ディスカバリーエンドポイントから取得 \{#fetch-from-openid-connect-discovery-endpoint}

これらの値は、Logto の OpenID Connect ディスカバリーエンドポイントから取得できます：

```
https://<your-logto-endpoint>/oidc/.well-known/openid-configuration
```

以下はレスポンス例です（他のフィールドは省略）：

```json
{
  "jwks_uri": "https://your-tenant.logto.app/oidc/jwks",
  "issuer": "https://your-tenant.logto.app/oidc"
}
```

### コード内でハードコーディング（非推奨） \{#hardcode-in-your-code-not-recommended}

Logto では JWKS URI や発行者 (Issuer) のカスタマイズができないため、これらの値をコード内でハードコーディングすることも可能です。ただし、将来的に設定が変更された場合の保守コストが増加するため、本番アプリケーションでは推奨されません。

- JWKS URI: `https://<your-logto-endpoint>/oidc/jwks`
- 発行者 (Issuer): `https://<your-logto-endpoint>/oidc`

## ステップ 3: トークンと権限の検証 \{#step-3-validate-the-token-and-permissions}

トークンを抽出し、OIDC 設定を取得した後、以下を検証します：

- **署名**：JWT が有効であり、Logto（JWKS 経由）によって署名されていること。
- **発行者 (Issuer)**：Logto テナントの発行者と一致すること。
- **オーディエンス (Audience)**：Logto に登録された API リソースインジケーター、または該当する場合は組織コンテキストと一致すること。
- **有効期限**：トークンが有効期限切れでないこと。
- **権限 (スコープ)**：API / アクションに必要なスコープがトークンに含まれていること。スコープは `scope` クレーム内のスペース区切り文字列です。
- **組織コンテキスト**：組織レベルの API リソースを保護する場合、`organization_id` クレームを検証します。

JWT の構造やクレームについて詳しくは [JSON Web Token](https://auth.wiki/jwt) を参照してください。

### 各権限モデルで確認すべき内容 \{#what-to-check-for-each-permission-model}

クレームや検証ルールは権限モデルによって異なります：

| 権限モデル              | Audience クレーム (`aud`)                                                    | Organization クレーム (`organization_id`) | チェックするスコープ（権限） (`scope`) |
| ----------------------- | ---------------------------------------------------------------------------- | ----------------------------------------- | -------------------------------------- |
| グローバル API リソース | API リソースインジケーター                                                   | _なし_                                    | API リソース権限                       |
| 組織（非 API）権限      | `urn:logto:organization:<id>`（組織コンテキストが `aud` クレームに含まれる） | _なし_                                    | 組織権限                               |
| 組織レベル API リソース | API リソースインジケーター                                                   | 組織 ID（リクエストと一致する必要あり）   | API リソース権限                       |

<small>
  非 API 組織権限の場合、組織コンテキストは `aud`
  クレーム（例：`urn:logto:organization:abc123`）で表現されます。`organization_id`
  クレームは組織レベル API リソース トークンにのみ存在します。
</small>

:::tip
セキュアなマルチテナント API のために、必ず権限（スコープ）とコンテキスト（オーディエンス、組織）の両方を検証してください。
:::

### 検証ロジックの追加 \{#add-the-validation-logic}

<Tabs groupId="api-language">
  <TabItem value="node" label="Node.js">
    <NodeAddValidationLogic />
  </TabItem>
  <TabItem value="python" label="Python">
    <PythonAddValidationLogic />
  </TabItem>
  <TabItem value="go" label="Go">
    <GoAddValidationLogic />
  </TabItem>
  <TabItem value="java" label="Java">
    <JavaAddValidationLogic />
  </TabItem>
  <TabItem value="dotnet" label=".NET">
    <DotNetAddValidationLogic />
  </TabItem>
  <TabItem value="php" label="PHP">
    <PhpAddValidationLogic />
  </TabItem>
  <TabItem value="ruby" label="Ruby">
    <RubyAddValidationLogic />
  </TabItem>
  <TabItem value="rust" label="Rust">
    <RustAddValidationLogic />
  </TabItem>
</Tabs>

## ステップ 4: API へミドルウェアを適用 \{#step-4-apply-middleware-to-your-api}

保護したい API ルートにミドルウェアを適用します。

<Tabs groupId="api-language">
  <TabItem value="node" label="Node.js">
    <NodeApplyMiddleware />
  </TabItem>
  <TabItem value="python" label="Python">
    <PythonApplyMiddleware />
  </TabItem>
  <TabItem value="go" label="Go">
    <GoApplyMiddleware />
  </TabItem>
  <TabItem value="java" label="Java">
    <JavaApplyMiddleware />
  </TabItem>
  <TabItem value="dotnet" label=".NET">
    <DotNetApplyMiddleware />
  </TabItem>
  <TabItem value="php" label="PHP">
    <PhpApplyMiddleware />
  </TabItem>
  <TabItem value="ruby" label="Ruby">
    <RubyApplyMiddleware />
  </TabItem>
  <TabItem value="rust" label="Rust">
    <RustApplyMiddleware />
  </TabItem>
</Tabs>

## ステップ 5: 実装のテスト \{#step-5-test-your-implementation}

有効なトークンと無効なトークンで API をテストし、以下を確認します：

- 有効なトークンは通過し、アクセスが許可されること。
- 無効または欠落したトークンには `401 Unauthorized` を返すこと。必要な権限やコンテキストが不足している有効なトークンには `403 Forbidden` を返すこと。

## 関連リソース \{#related-resources}

<Url href="/developers/custom-token-claims">トークン クレームのカスタマイズ</Url>
<Url href="https://auth.wiki/ja/jwt">JSON Web Token (JWT)</Url>
<Url href="https://openid.net/specs/openid-connect-discovery-1_0.html">
  OpenID Connect Discovery
</Url>
<Url href="https://www.rfc-editor.org/rfc/rfc8707.html">RFC 8707: リソースインジケーター</Url>
