---
sidebar_position: 1
sidebar_label: RBAC en la pr√°ctica
description: 'Una gu√≠a pr√°ctica sobre el control de acceso basado en roles (RBAC): Aprende c√≥mo dise√±ar permisos, gestionar roles y configurar una autorizaci√≥n segura en tu CMS.'
---

<head>
  <link rel="canonical" href="https://blog.logto.io/rbac-in-practice" />
</head>

# RBAC en la pr√°ctica: Implementando autorizaci√≥n segura para tu aplicaci√≥n

¬øTienes dificultades para implementar un sistema de autorizaci√≥n seguro y escalable para tu aplicaci√≥n? El Control de Acceso Basado en Roles (RBAC) es el est√°ndar de la industria para gestionar los permisos de usuario, pero implementarlo correctamente puede ser un reto. Este tutorial te mostrar√° c√≥mo construir un sistema RBAC robusto usando un ejemplo real de un Sistema de Gesti√≥n de Contenidos (CMS).

Siguiendo esta gu√≠a, aprender√°s:

- ‚ú® C√≥mo dise√±ar e implementar permisos granulares que te den control preciso
- üîí Mejores pr√°cticas para organizar permisos en roles significativos
- üë§ T√©cnicas para gestionar la propiedad de recursos de manera efectiva
- üöÄ Formas de hacer que tu sistema de autorizaci√≥n sea escalable y f√°cil de mantener
- üí° Implementaci√≥n pr√°ctica usando un ejemplo real de CMS

El c√≥digo fuente completo de este tutorial est√° disponible en [GitHub](https://github.com/logto-io/rbac-sample).

## Entendiendo los fundamentos de RBAC \{#understanding-rbac-fundamentals}

El Control de Acceso Basado en Roles es m√°s que solo asignar permisos a los usuarios. Se trata de crear un enfoque estructurado para la autorizaci√≥n que equilibre la seguridad con la facilidad de mantenimiento.

Puedes aprender m√°s sobre [¬øQu√© es RBAC?](https://auth-wiki.logto.io/rbac) en Auth Wiki.

Estos son los principios clave que seguiremos en nuestra implementaci√≥n:

### Dise√±o de permisos granulares \{#fine-grained-permission-design}

Los permisos granulares te dan control preciso sobre lo que los usuarios pueden hacer en tu sistema. En lugar de niveles de acceso amplios como "admin" o "user", definimos acciones espec√≠ficas que los usuarios pueden realizar sobre los recursos. Por ejemplo:

- `read:articles` - Ver cualquier art√≠culo en el sistema
- `create:articles` - Crear nuevos art√≠culos
- `update:articles` - Modificar art√≠culos existentes
- `publish:articles` - Cambiar el estado de publicaci√≥n de los art√≠culos

### Propiedad de recursos y control de acceso \{#resource-ownership-and-access-control}

La propiedad de recursos es un concepto fundamental en el dise√±o de autorizaci√≥n de nuestro CMS. Mientras que RBAC define qu√© acciones pueden realizar los diferentes roles, la propiedad a√±ade una dimensi√≥n personal al control de acceso:

- Los autores tienen acceso autom√°ticamente a los art√≠culos que crearon
- Este modelo de propiedad natural significa que los autores siempre pueden ver y editar su propio contenido
- El sistema verifica tanto los permisos de rol O la propiedad al manejar operaciones sobre art√≠culos
- Por ejemplo, incluso sin el permiso `update:articles`, un autor puede editar sus propios art√≠culos
- Este dise√±o reduce la necesidad de permisos adicionales de rol mientras mantiene la seguridad

Este enfoque de doble capa (roles + propiedad) crea un sistema m√°s intuitivo y seguro. Los editores y administradores pueden seguir gestionando todo el contenido a trav√©s de sus permisos de rol, mientras que los autores mantienen el control sobre su propio trabajo.

## Dise√±ando APIs seguras \{#designing-a-secure-apis}

Comencemos dise√±ando la funcionalidad principal de nuestro CMS a trav√©s de sus endpoints de API:

```
GET    /api/articles         # Listar todos los art√≠culos
GET    /api/articles/:id     # Obtener un art√≠culo espec√≠fico
POST   /api/articles         # Crear un nuevo art√≠culo
PATCH  /api/articles/:id     # Actualizar un art√≠culo
DELETE /api/articles/:id     # Eliminar un art√≠culo
PATCH  /api/articles/:id/published  # Cambiar el estado de publicaci√≥n
```

### Implementar control de acceso para tu API \{#implement-access-control-for-your-api}

Para cada endpoint, necesitamos considerar dos aspectos del control de acceso:

1. Propiedad del recurso - ¬øEl usuario es due√±o de este recurso?
2. Permisos basados en roles - ¬øEl rol del usuario permite esta operaci√≥n?

As√≠ es como manejaremos el acceso para cada endpoint:

| Endpoint                          | L√≥gica de control de acceso                                                          |
| --------------------------------- | ------------------------------------------------------------------------------------ |
| GET /api/articles                 | - Cualquiera con permiso `list:articles`, O autores pueden ver sus propios art√≠culos |
| GET /api/articles/:id             | - Cualquiera con permiso `read:articles`, O autor del art√≠culo                       |
| POST /api/articles                | - Cualquiera con permiso `create:articles`                                           |
| PATCH /api/articles/:id           | - Cualquiera con permiso `update:articles`, O autor del art√≠culo                     |
| DELETE /api/articles/:id          | - Cualquiera con permiso `delete:articles`, O autor del art√≠culo                     |
| PATCH /api/articles/:id/published | - Solo usuarios con permiso `publish:articles`                                       |

### Crear un sistema de permisos que escale \{#creating-a-permission-system-that-scales}

Seg√∫n los requisitos de acceso a nuestra API, podemos definir estos permisos:

| Permiso          | Descripci√≥n                                       |
| ---------------- | ------------------------------------------------- |
| list:articles    | Ver la lista de todos los art√≠culos en el sistema |
| read:articles    | Leer el contenido completo de cualquier art√≠culo  |
| create:articles  | Crear nuevos art√≠culos                            |
| update:articles  | Modificar cualquier art√≠culo                      |
| delete:articles  | Eliminar cualquier art√≠culo                       |
| publish:articles | Cambiar el estado de publicaci√≥n                  |

Ten en cuenta que estos permisos solo son necesarios al acceder a recursos que no posees. Los propietarios de art√≠culos pueden autom√°ticamente:

- Ver sus propios art√≠culos (no se necesita `read:articles`)
- Editar sus propios art√≠culos (no se necesita `update:articles`)
- Eliminar sus propios art√≠culos (no se necesita `delete:articles`)

## Construyendo roles efectivos \{#building-effective-roles}

Ahora que tenemos nuestra API y permisos definidos, podemos crear roles que agrupen estos permisos l√≥gicamente:

| Permiso/Rol      | üëë Admin                                      | üìù Publisher                                          | ‚úçÔ∏è Author                                  |
| ---------------- | --------------------------------------------- | ----------------------------------------------------- | ------------------------------------------ |
| **Descripci√≥n**  | Acceso total al sistema para gesti√≥n completa | Puede ver todos los art√≠culos y controlar publicaci√≥n | Puede crear nuevos art√≠culos en el sistema |
| list:articles    | ‚úÖ                                            | ‚úÖ                                                    | ‚ùå                                         |
| read:articles    | ‚úÖ                                            | ‚úÖ                                                    | ‚ùå                                         |
| create:articles  | ‚úÖ                                            | ‚ùå                                                    | ‚úÖ                                         |
| update:articles  | ‚úÖ                                            | ‚ùå                                                    | ‚ùå                                         |
| delete:articles  | ‚úÖ                                            | ‚ùå                                                    | ‚ùå                                         |
| publish:articles | ‚úÖ                                            | ‚úÖ                                                    | ‚ùå                                         |

**Nota**: Los autores tienen autom√°ticamente permisos de lectura / actualizaci√≥n / eliminaci√≥n para sus propios art√≠culos, independientemente de los permisos de rol.

Cada rol est√° dise√±ado con responsabilidades espec√≠ficas en mente:

- **Admin**: Tiene control total sobre el CMS, incluyendo todas las operaciones sobre art√≠culos
- **Publisher**: Se enfoca en la revisi√≥n de contenido y gesti√≥n de la publicaci√≥n
- **Author**: Se especializa en la creaci√≥n de contenido

Esta estructura de roles crea una clara separaci√≥n de responsabilidades:

- Los autores se enfocan en crear contenido
- Los editores gestionan la calidad y visibilidad del contenido
- Los administradores mantienen el control general del sistema

## Configura RBAC en Logto \{#config-rbac-in-logto}

Antes de comenzar, necesitas crear una cuenta en [Logto Cloud](https://cloud.logto.io), o tambi√©n puedes usar una instancia autogestionada de Logto utilizando la [versi√≥n Logto OSS](/logto-oss).

Pero para este tutorial, usaremos Logto Cloud por simplicidad.

### Configurando tu aplicaci√≥n \{#setting-up-your-application}

1. Ve a "Applications" en Logto Console para crear una nueva aplicaci√≥n react
   - Nombre de la aplicaci√≥n: Content Management System
   - Tipo de aplicaci√≥n: Traditional Web Application
   - Redirect URIs: http://localhost:5173/callback

![Aplicaci√≥n React CMS](https://uploads.strapi.logto.io/cms_application_3ed42f2256.png)

### Configurando recursos de API y permisos \{#configuring-api-resources-and-permissions}

1. Ve a "API Resources" en Logto Console para crear un nuevo recurso de API
   - Nombre de la API: CMS API
   - Identificador de la API: https://api.cms.com
   - Agrega permisos al recurso de API
     - `list:articles`
     - `read:articles`
     - `create:articles`
     - `update:articles`
     - `publish:articles`
     - `delete:articles`

![Detalles del recurso de API CMS](https://uploads.strapi.logto.io/cms_api_resource_b15ae2b91a.png)

### Creando roles \{#creating-roles}

Ve a Roles en Logto Console para crear los siguientes roles para el CMS

- Admin
  - con todos los permisos
- Publisher
  - con `read:articles`, `list:articles`, `publish:articles`
- Author
  - con `create:articles`

![Rol Admin](https://uploads.strapi.logto.io/admin_role_53edb35ecf.png)

![Rol Publisher](https://uploads.strapi.logto.io/publisher_role_2ac205cc32.png)

![Rol Author](https://uploads.strapi.logto.io/author_role_f89cd99543.png)

### Asignando roles a los usuarios \{#assigning-roles-to-users}

Ve a la secci√≥n "User management" en Logto Console para crear usuarios.

En la pesta√±a "Roles" de los detalles del usuario, puedes asignar roles al usuario.

En nuestro ejemplo, creamos 3 usuarios con los siguientes roles:

- Alex: Admin
- Bob: Publisher
- Charlie: Author

![Gesti√≥n de usuarios](https://uploads.strapi.logto.io/user_management_c0bc17119f.png)

![Detalles de usuario - Alex](https://uploads.strapi.logto.io/user_details_alex_702f96ef9a.png)

:::note
Para fines de demostraci√≥n, creamos estos recursos y configuraciones a trav√©s de Logto Console. En proyectos reales, puedes crear estos recursos y configuraciones program√°ticamente usando la [Management API](/integrate-logto/interact-with-management-api) proporcionada por Logto.
:::

## Integra tu frontend con Logto RBAC \{#integrate-your-frontend-with-logto-rbac}

Ahora que hemos configurado RBAC en Logto, podemos comenzar a integrarlo en nuestro frontend.

Primero, sigue los [Logto Quick Starts](/quick-starts) para integrar Logto en tu aplicaci√≥n.

En nuestro ejemplo, usamos [React](/quick-starts/react) para la demostraci√≥n.

Despu√©s de configurar Logto en tu aplicaci√≥n, necesitamos agregar las configuraciones de RBAC para que Logto funcione.

```tsx
// frontend/src/App.tsx

const logtoConfig: LogtoConfig = {
  appId: LOGTO_APP_ID, // El ID de la app que creaste en Logto Console
  endpoint: LOGTO_ENDPOINT, // El endpoint que creaste en Logto Console
  resources: [API_RESOURCE], // El identificador del recurso de API que creaste en Logto Console, por ejemplo https://api.cms.com
  // Todos los alcances (scopes) que podr√≠as querer solicitar del recurso de API en el frontend
  scopes: [
    'list:articles',
    'create:articles',
    'read:articles',
    'update:articles',
    'delete:articles',
    'publish:articles',
  ],
};
```

Recuerda cerrar sesi√≥n e iniciar sesi√≥n nuevamente para que este cambio tenga efecto si ya has iniciado sesi√≥n.

Cuando el usuario inicia sesi√≥n con Logto y solicita un token de acceso para los recursos de API especificados arriba, Logto agregar√° alcances (permisos) relacionados con el rol del usuario al token de acceso.

Puedes usar `getAccessTokenClaims` del hook `useLogto` para obtener los alcances del token de acceso.

```tsx
// frontend/src/hooks/use-user-data.ts

import { useLogto } from '@logto/react';
import { API_RESOURCE } from '../config';
import { useState, useEffect } from 'react';

export const useUserData = () => {
  const { getAccessTokenClaims } = useLogto();
  const [userScopes, setUserScopes] = useState<string[]>([]);
  const [userId, setUserId] = useState<string>();

  useEffect(() => {
    const fetchScopes = async () => {
      const token = await getAccessTokenClaims(API_RESOURCE);
      setUserScopes(token?.scope?.split(' ') ?? []);
      setUserId(token?.sub);
    };

    fetchScopes();
  }, [getAccessTokenClaims]);

  return { userId, userScopes };
};
```

Y puedes usar `userScopes` para verificar si el usuario tiene permiso para acceder al recurso.

```tsx
// frontend/src/pages/Dashboard.tsx

const Dashboard = () => {
  const { userId, userScopes } = useUserData();
  // ...

  return (
    <div>
      {/* ... */}
      {(userScopes.includes('delete:articles') || article.ownerId === userId) && (
        <button
          onClick={() => handleDelete(article.id)}
          className="text-red-600 hover:text-red-900"
        >
          Delete
        </button>
      )}
    </div>
  );
};
```

## Integra tu backend con Logto RBAC \{#integrate-your-backend-with-logto-rbac}

Ahora es momento de integrar Logto RBAC en tu backend.

### Middleware de autorizaci√≥n en el backend \{#backend-authorization-middleware}

Primero, necesitamos agregar un middleware en el backend para verificar los permisos del usuario, comprobar si el usuario ha iniciado sesi√≥n y determinar si tiene los permisos necesarios para acceder a ciertas APIs.

```javascript
// backend/src/middleware/auth.js

const { createRemoteJWKSet, jwtVerify } = require('jose');

const getTokenFromHeader = (headers) => {
  const { authorization } = headers;
  const bearerTokenIdentifier = 'Bearer';

  if (!authorization) {
    throw new Error('Authorization header missing');
  }

  if (!authorization.startsWith(bearerTokenIdentifier)) {
    throw new Error('Authorization token type not supported');
  }

  return authorization.slice(bearerTokenIdentifier.length + 1);
};

const hasScopes = (tokenScopes, requiredScopes) => {
  if (!requiredScopes || requiredScopes.length === 0) {
    return true;
  }
  const scopeSet = new Set(tokenScopes);
  return requiredScopes.every((scope) => scopeSet.has(scope));
};

const verifyJwt = async (token) => {
  const JWKS = createRemoteJWKSet(new URL(process.env.LOGTO_JWKS_URL));

  const { payload } = await jwtVerify(token, JWKS, {
    issuer: process.env.LOGTO_ISSUER,
    audience: process.env.LOGTO_API_RESOURCE,
  });

  return payload;
};

const requireAuth = (requiredScopes = []) => {
  return async (req, res, next) => {
    try {
      // Extraer el token
      const token = getTokenFromHeader(req.headers);

      // Verificar el token
      const payload = await verifyJwt(token);

      // Agregar informaci√≥n del usuario a la request
      req.user = {
        id: payload.sub,
        scopes: payload.scope?.split(' ') || [],
      };

      // Verificar los alcances requeridos
      if (!hasScopes(req.user.scopes, requiredScopes)) {
        throw new Error('Insufficient permissions');
      }

      next();
    } catch (error) {
      res.status(401).json({ error: 'Unauthorized' });
    }
  };
};

module.exports = {
  requireAuth,
  hasScopes,
};
```

Como puedes ver, en este middleware verificamos si la solicitud del frontend contiene un token de acceso v√°lido y comprobamos si la audiencia del token de acceso coincide con el recurso de API que creamos en Logto Console.

La raz√≥n para verificar el recurso de API es que nuestro recurso de API realmente representa los recursos de nuestro backend CMS, y todos nuestros permisos del CMS est√°n asociados a este recurso de API.

Dado que este recurso de API representa los recursos del CMS en Logto, en nuestro c√≥digo frontend, incluimos el correspondiente Access token al hacer solicitudes de API al backend:

```typescript
// frontend/src/hooks/use-api.ts
export const useApi = () => {
  const { getAccessToken } = useLogto();

  return useMemo(
    () =>
      async (endpoint: string, options: RequestInit = {}) => {
        try {
          // Obtener el access token para el recurso de API
          const token = await getAccessToken(API_RESOURCE);

          if (!token) {
            throw new ApiRequestError('Failed to get access token');
          }

          const response = await fetch(`${API_BASE_URL}${endpoint}`, {
            ...options,
            headers: {
              'Content-Type': 'application/json',
              // Agregar el access token a los headers de la solicitud
              Authorization: `Bearer ${token}`,
              ...options.headers,
            },
          });

          // ... manejar respuesta

          return await response.json();
        } catch (error) {
          // ... manejo de errores
        }
      },
    [getAccessToken]
  );
};
```

Ahora podemos usar el middleware `requireAuth` para proteger nuestros endpoints de API.

### Protegiendo endpoints de API \{#protecting-api-endpoints}

Para las APIs que solo deben ser accesibles por usuarios con permisos espec√≠ficos, podemos agregar restricciones directamente en el middleware. Por ejemplo, la API de creaci√≥n de art√≠culos solo debe ser accesible para usuarios con el permiso `create:articles`:

```javascript
// backend/src/routes/articles.js

const { requireAuth } = require('../middleware/auth');

router.post('/articles', requireAuth(['create:articles']), async (req, res) => {
  // ...
});
```

Para las APIs que necesitan verificar tanto permisos como propiedad del recurso, podemos usar la funci√≥n `hasScopes`. Por ejemplo, en la API de listado de art√≠culos, los usuarios con el alcance `list:articles` pueden acceder a todos los art√≠culos, mientras que los autores pueden acceder a los art√≠culos que han creado:

```javascript
// backend/src/routes/articles.js

const { requireAuth, hasScopes } = require('../middleware/auth');

router.get('/articles', requireAuth(), async (req, res) => {
  try {
    // Si el usuario tiene el scope list:articles, devolver todos los art√≠culos
    if (hasScopes(req.user.scopes, ['list:articles'])) {
      const articles = await articleDB.list();
      return res.json(articles);
    }

    // De lo contrario, devolver solo los art√≠culos del usuario
    const articles = await articleDB.listByOwner(req.user.id);
    res.json(articles);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch articles' });
  }
});
```

En este punto, hemos completado la implementaci√≥n de RBAC. Puedes consultar [el c√≥digo fuente completo](https://github.com/logto-io/rbac-sample) para ver la implementaci√≥n completa.

## Prueba la implementaci√≥n de RBAC en el CMS \{#test-the-cms-rbac-implementation}

Ahora, probemos nuestra implementaci√≥n de RBAC en el CMS usando los tres usuarios que acabamos de crear.

:::note
Si ves que no puedes iniciar sesi√≥n con las credenciales de los usuarios creados en "User Management", primero deber√°s habilitar el m√©todo de inicio de sesi√≥n adecuado. Ve a "Sign-in Experience" en Logto Console y habilita tu m√©todo de autenticaci√≥n preferido (como Email + Password o Username + Password).
:::

Primero, iniciemos sesi√≥n como Alex y Charles respectivamente y creemos algunos art√≠culos.

Como Alex tiene el rol de Admin, puede crear, eliminar, actualizar, publicar y ver todos los art√≠culos.

![Panel CMS - Alex](https://uploads.strapi.logto.io/cms_dashboard_alex_a11863a94b.png)

Charles, con el rol de Author, solo puede crear sus propios art√≠culos y solo puede ver, actualizar y eliminar los art√≠culos que posee.

![Panel CMS - Charles - Lista de art√≠culos](https://uploads.strapi.logto.io/cms_dashboard_charles_05f610066a.png)

Bob, con el rol de Publisher, puede ver y publicar todos los art√≠culos pero no puede crearlos, actualizarlos ni eliminarlos.

![Panel CMS - Bob](https://uploads.strapi.logto.io/cms_dashboard_bob_421a429b69.png)

## Conclusi√≥n \{#conclusion}

¬°Felicidades! Has aprendido c√≥mo implementar un sistema RBAC robusto en tu aplicaci√≥n.

Para escenarios m√°s complejos, como la construcci√≥n de aplicaciones multi-tenant, Logto proporciona soporte completo para organizaciones. Consulta nuestra gu√≠a [Construye una aplicaci√≥n SaaS multi-tenant: Una gu√≠a completa desde el dise√±o hasta la implementaci√≥n](https://blog.logto.io/build-multi-tenant-saas-application) para aprender m√°s sobre c√≥mo implementar control de acceso a nivel organizacional.

¬°Feliz programaci√≥n! üöÄ
