---
id: platform-sdk-convention
title: Конвенция Platform SDK
sidebar_label: Конвенция Platform SDK
sidebar_position: 4
---

# Конвенция Platform SDK

Platform SDK предоставляет стандартный способ интеграции клиента с сервисом Logto на конкретной платформе и ускоряет процесс интеграции.

- Platform SDK инкапсулирует [ядро](/developers/sdk-conventions/core-sdk-convention) с платформенно-специфичной реализацией.
- Platform SDK должен предоставлять базовые типы, которые упрощают использование SDK.
- Platform SDK должен экспортироваться как класс с именем `LogtoClient`.

## Базовые типы \{#basic-types}

<details>
  <summary>

### LogtoConfig \{#logtoconfig}

</summary>

| Name                | Type       | Required | Default Value                       | Notes                                                                                   |
| ------------------- | ---------- | -------- | ----------------------------------- | --------------------------------------------------------------------------------------- |
| endpoint            | `string`   | ✅       |                                     | Эндпоинт OIDC сервиса.                                                                  |
| appId               | `string`   | ✅       |                                     | Идентификатор приложения, полученный из зарегистрированного в Logto Service приложения. |
| scopes              | `string[]` |          | `[openid, offline_access, profile]` | Это поле всегда содержит `openid`, `offline_access` и `profile`.                        |
| resources           | `string[]` |          |                                     | Индикаторы защищенных ресурсов, которые мы хотим использовать.                          |
| prompt              | `string`   |          | `consent`                           | Значение prompt, используемое в `generateSignInUri`.                                    |
| usingPersistStorage | `boolean`  |          | `true`                              | Решает, сохранять ли учетные данные на локальной машине.                                |

**\*Примечания**

- Вы можете расширить этот `LogtoConfig`, если это необходимо.
- `usingPersistStorage` предоставляется только в клиентских SDK, например, iOS, Android и SPA.

</details>

<details>
  <summary>

### AccessToken \{#accesstoken}

</summary>

| Name      | Type     | Notes                      |
| --------- | -------- | -------------------------- |
| token     | `string` |                            |
| scope     | `string` |                            |
| expiresAt | `number` | Временная метка в секундах |

</details>

## LogtoClient \{#logtoclient}

### Свойства \{#properties}

<details>
  <summary>

### logtoConfig \{#logtoconfig-1}

</summary>

**Тип**

`LogtoConfig`

</details>

<details>
  <summary>

### oidcConfig \{#oidcconfig}

</summary>

**Тип**

`OidcConfigResponse?`

</details>

<details>
  <summary>

### accessTokenMap \{#accesstokenmap}

</summary>

**Тип**

`Map<string, AccessToken>`

**Ключ**

- Ключ должен быть составлен из `scope` и `resource`.
- Значения в `scope` должны быть отсортированы в алфавитном порядке и объединены пробелом.
- Ключ должен быть составлен по шаблону: `${scope}@${resource}`.
- Если `scope` или `resource` пусты или равны null, их значение должно рассматриваться как пустое.

Например, `"offline_access openid read:usr@https://logto.dev/api"`, `"@https://logto.dev/api"`, `"openid@"`, `"@"`.

**Значение**

- `AccessToken`, который использует свойство `expiresAt` для указания точного времени, когда токен доступа истекает.

**Примечания**

- `scope` всегда будет иметь значение null, так как мы не поддерживаем пользовательские области в Logto V1.
- При создании ключа токена доступа для хранения токена доступа:
  - `scope` всегда будет иметь значение null.
  - если токен доступа не является jwt, рассматривайте `resource` как значение null.
  - если токен доступа является jwt, декодируйте токен доступа и используйте значение утверждения `aud` из полезной нагрузки в качестве части `resource` ключа токена доступа.

</details>

<details>
  <summary>

### refreshToken \{#refreshtoken}

</summary>

**Тип**

`string?`

**Примечания**

`refreshToken` будет установлен или обновлен в следующих случаях:

- Загрузка `refreshToken` из хранилища.
- Сервер возвращает `refreshToken` в ответе при успешном получении токена.
- Выход из системы (будет установлен в `null`).

</details>

<details>
  <summary>

### idToken \{#idtoken}

</summary>

**Тип**

`string?`

**Примечания**

- `idToken` должен быть проверен, если он поступает с бэкенда.
- `idToken` будет установлен или обновлен в следующих случаях:
  - Загрузка `idToken` из хранилища.
  - Сервер возвращает `idToken` в ответе при успешном получении токена.
  - Выход из системы (будет установлен в `null`).

</details>

### Методы \{#methods}

<details>
  <summary>

### constructor \{#constructor}

</summary>

**Параметры**

| Параметр    | Тип           |
| ----------- | ------------- |
| logtoConfig | `LogtoConfig` |

**Тип возврата**

`LogtoClient`

**Примечания**

- Вы можете добавить дополнительные параметры, если это необходимо.
- Если в logtoConfig включено использование постоянного хранилища, Platform SDK предоставит следующие функции:
  - Хранение постоянных данных с уникальным ключом на основе `clientId`.
  - Загрузка `refreshToken` и `idToken` с локальной машины при инициализации.
  - Хранение `refreshToken` и `idToken` локально при `Core.fetchTokenByAuthorizationCode` и `Core.fetchTokenByRefreshToken`.

</details>

<details>
  <summary>

### isAuthenticated \{#isauthenticated}

</summary>

Чтобы узнать, аутентифицирован ли пользователь или нет.  
Это также может быть определено как геттер.

Пользователь считается аутентифицированным, когда:

- Мы успешно получили ID токен.
- Мы загрузили ID токен с локальной машины.

**Параметры**

Нет.

**Тип возврата**

`boolean`

</details>

<details>
  <summary>

### SignIn \{#signin}

</summary>

Этот метод должен начать процесс входа, и Platform SDK должен позаботиться обо всех шагах, необходимых для завершения авторизации, включая процесс перенаправления на вход.

Пользователь будет аутентифицирован после успешного вызова этого метода.

Процесс входа будет полагаться на функции Core SDK:

- `generateSignInUri`
- `verifyAndParseCodeFromCallbackUri`
- `fetchTokenByAuthorizationCode`

Примечания:

- Поскольку generateSignInUri включает ресурсы, которые нам нужны, нам не нужно передавать ресурс в функцию fetchTokenByAuthorizationCode.

**Параметры**

| Параметр    | Тип      |
| ----------- | -------- |
| redirectUri | `string` |

**Тип возврата**

`void`

**Исключения**

- Любая ошибка, возникшая в процессе входа.

</details>

<details>
  <summary>

### SignOut \{#signout}

</summary>

Процесс выхода должен следовать следующим шагам:

1. Очистить локальное хранилище, куки, постоянные данные или что-то еще.
2. Отозвать полученный токен обновления через `Core.revoke` (сервис Logto отзовет все связанные токены, если токен обновления отозван).
3. Перенаправить пользователя на эндпоинт выхода Logto, если шаг 1 не очистил сессию страницы входа.

Примечания:

- На шаге 2 `Core.revoke` является асинхронным вызовом и не будет блокировать процесс выхода, даже если он завершится неудачей.
- Шаг 3 полагается на `Core.generateSignOutUri` для генерации эндпоинта выхода Logto.

**Параметры**

| Параметр              | Тип      | Обязательный | Значение по умолчанию |
| --------------------- | -------- | ------------ | --------------------- |
| postLogoutRedirectUri | `string` |              | `null`                |

**Тип возврата**

`void`

**Исключения**

- Любая ошибка, возникшая в процессе выхода.

</details>

<details>
  <summary>

### getAccessToken \{#getaccesstoken}

</summary>

`getAccessToken` извлекает `AccessToken` по `resource` и `scope` из `accessTokenMap`, затем возвращает значение `token` этого `AccessToken`.

Мы устанавливаем `scope` в `null` при создании ключа `accessTokenMap`, так как мы не поддерживаем пользовательские области в Logto V1.

**Примечания**

- Если не удается найти соответствующий `AccessToken`, выполните действие `Core.fetchTokenByRefreshToken` для получения необходимого токена.
- Если `accessToken` не истек, верните значение `token` внутри.
- Если `accessToken` истек, выполните действие `Core.fetchTokenByRefreshToken` для получения нового `accessToken`, обновите локальный `accessTokenMap` и верните новое значение `token` внутри.
- Если `Core.fetchTokenByRefreshToken` завершился неудачей, сообщите пользователю об исключении, которое произошло.
- Если не удается найти refreshToken, сообщите пользователю об исключении неавторизованного доступа.
- Только получив `refreshToken` после входа, мы можем выполнить действие `Core.fetchTokenByRefreshToken`.

**Параметры**

| Параметр | Тип      | Обязательный | Значение по умолчанию |
| -------- | -------- | ------------ | --------------------- |
| resource | `string` |              | `null`                |

**Тип возврата**

`string`

**Исключения**

- Пользователь не аутентифицирован.
- Входной `resource` не установлен в `logtoConfig`.
- Не найден токен обновления перед `Core.fetchTokenByRefreshToken`.
- `Core.fetchTokenByRefreshToken` завершился неудачей.

</details>

<details>
  <summary>

### getIdTokenClaims \{#getidtokenclaims}

</summary>

`getIdTokenClaims` возвращает объект, содержащий утверждения свойства `idToken`.

**Параметры**

Нет.

**Тип возврата**

`IdTokenClaims`

**Исключения**

- Пользователь не аутентифицирован.

</details>
