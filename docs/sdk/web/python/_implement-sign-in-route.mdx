import redirectUriFigure from '../../assets/go-redirect-uri.png';
import ConfigureRedirectUri from '../../fragments/_configure-redirect-uri.mdx';
import SignInFlowSummary from '../../fragments/_web-sign-in-flow-summary.mdx';

<SignInFlowSummary />

Before you start implementing the sign-in flow, you need to add a redirect URI in the Admin Console for your application.

<ConfigureRedirectUri
  figureSrc={redirectUriFigure}
  redirectUri="http://localhost:8080/sign-in-callback"
/>

In your web application, add a route to properly handle the sign-in request from users. Let's use `/sign-in` as an example:

```python
@app.route("/sign-in")
async def sign_in():
    # Get the sign-in URL and redirect the user to it
    return redirect(await client.signIn(
        redirectUri="http://localhost:8080/sign-in-callback",
    ))
```

Replace `http://localhost:8080/sign-in-callback` with the callback URL you set in your Logto Console for this application.

If you want to show the sign-up page on the first screen, you can set `interactionMode` to `signUp`:

```python
@app.route("/sign-in")
async def sign_in():
    return redirect(await client.signIn(
        redirectUri="http://localhost:8080/sign-in-callback",
        interactionMode="signUp", # Show the sign-up page on the first screen
    ))
```

Now, whenever your users visit `http://localhost:8080/sign-in`, it will start a new sign-in attempt and redirect the user to the Logto sign-in page.

> **Note**
> Creating a sign-in route isn't the only way to start a sign-in attempt. You can always use the `signIn` method to get the sign-in URL and redirect the user to it.

Here we also implement a simple home page for demonstration:

- If the user is not signed in, show a sign-in button;
- If the user is signed in, show some basic information about the user.

```python
@app.route("/")
async def home():
    if client.isAuthenticated() is False:
        return "Not authenticated <a href='/sign-in'>Sign in</a>"

    return (
        # Get local ID token claims
        client.getIdTokenClaims().model_dump_json(exclude_unset=True)
        + "<br>"
        # Fetch user info from Logto userinfo endpoint
        (await client.fetchUserInfo()).model_dump_json(exclude_unset=True)
        + "<br><a href='/sign-out'>Sign out</a>"
    )
```

Our data models are based on [pydantic](https://docs.pydantic.dev/), so you can use `model_dump_json` to dump the data model to JSON.

Adding `exclude_unset=True` will exclude unset fields from the JSON output, which makes the output more precise.

For example, if we didn't request the `email` scope when signing in, and the `email` field will be excluded from the JSON output. However, if we requested the `email` scope, but the user doesn't have an email address, the `email` field will be included in the JSON output with a `null` value.

To learn more about scopes and claims, see [Scopes and claims](#scopes-and-claims).
